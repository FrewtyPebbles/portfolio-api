{"root": {"projects\\Python Image Processor\\root": {"projects\\Python Image Processor\\root\\image.py": "import math\nfrom PIL import Image\nfrom numpy import array\nimport numpy as np\n\nVER = \"0.2.1\"\n\nclass ImageProcessor:\n    def __init__(self, image: str) -> None:\n        self.image = Image.open(image)\n        self.matrix = array(self.image)\n\n    def desaturate(self, percent, show_progress=False):\n        percent /= 100\n        num_of_rows = len(self.matrix)\n        last_percent = -1\n        for rn, row in enumerate(self.matrix):\n            num_of_cols = len(row)\n            for cn, column in enumerate(row):\n                average = sum(column)/len(column)\n                self.matrix[rn, cn] = [column[0] + \\\n                    (average - column[0])*percent, column[1] + \\\n                    (average - column[1])*percent, column[2] + \\\n                    (average - column[2])*percent, 255]\n            if last_percent != int(rn/num_of_rows*100) and show_progress:\n                if last_percent >= 0:\n                    print(\"\\033[A\\033[A\")\n                print(f\" Desaturating Image [{int(rn/num_of_rows*100)}%]\")\n            last_percent = int(rn/num_of_rows*100)\n        if show_progress:\n            print(\"\\033[A\\033[A\")\n            print(f\" Desaturating Image [100%]\")\n        return self\n\n    def saturate(self, percent, show_progress=False):\n        percent /= 100\n        num_of_rows = len(self.matrix)\n        last_percent = -1\n        for rn, row in enumerate(self.matrix):\n            for cn, column in enumerate(row):\n                average = (int(column[0]) + int(column[1]) + int(column[2]))/3\n                for cvn, col_val in enumerate(column):\n                    if col_val > average:\n                        self.matrix[rn, cn,\n                                    cvn] += (225 - float(col_val))*percent\n                    else:\n                        self.matrix[rn, cn, cvn] -= float(col_val)*percent\n            if last_percent != int(rn/num_of_rows*100) and show_progress:\n                if last_percent >= 0:\n                    print(\"\\033[A\\033[A\")\n                print(f\" Saturating Image [{int(rn/num_of_rows*100)}%]\")\n            last_percent = int(rn/num_of_rows*100)\n        if show_progress:\n            print(\"\\033[A\\033[A\")\n            print(f\" Saturating Image [100%]\")\n        return self\n\n    def bnw(self, threshold, show_progress=False):\n        num_of_rows = len(self.matrix)\n        last_percent = -1\n        for rn, row in enumerate(self.matrix):\n            for cn, column in enumerate(row):\n                average = (int(column[0]) + int(column[1]) + int(column[2]))/3\n                if len(self.matrix[rn, cn]) == 3:\n                    if average > threshold:\n                        self.matrix[rn, cn] = [255, 255, 255]\n                    else:\n                        self.matrix[rn, cn] = [0, 0, 0]\n                else:\n                    if average > threshold:\n                        self.matrix[rn, cn] = [255, 255, 255, 255]\n                    else:\n                        self.matrix[rn, cn] = [0, 0, 0, 255]\n            if last_percent != int(rn/num_of_rows*100) and show_progress:\n                if last_percent >= 0:\n                    print(\"\\033[A\\033[A\")\n                print(f\" Black & White [{int(rn/num_of_rows*100)}%]\")\n            last_percent = int(rn/num_of_rows*100)\n        if show_progress:\n            print(\"\\033[A\\033[A\")\n            print(f\" Black & White [100%]\")\n        return self\n\n    def _get_avg_shades(self, threshold, show_progress=False):\n        shades = []\n        num_of_rows = len(self.matrix)\n        last_percent = -1\n        current_average = []\n        for rn, row in enumerate(self.matrix):\n            for cn, column in enumerate(row):\n                avg_shade = sum(column)/len(column)\n                diff = []\n                avg_diff = 0\n                if len(current_average) == 0:\n                    current_average = column\n                    continue\n                else:\n                    diff = [abs(int(column[i]) - int(current_average[i]))\n                            for i in range(0, len(column))]\n                    avg_diff = sum(diff)/len(diff)\n                if avg_diff < threshold:\n                    current_average = [((int(current_average[col_ind]) + int(column[col_ind]))/2)\n                                       for col_ind in range(0, len(column))]\n                else:\n                    shades.append(current_average)\n                    current_average = column\n            if last_percent != int(rn/num_of_rows*100) and show_progress:\n                if last_percent >= 0:\n                    print(\"\\033[A\\033[A\")\n                print(f\"   Getting Shades [{int(rn/num_of_rows*100)}%]\")\n            last_percent = int(rn/num_of_rows*100)\n        if show_progress:\n            print(\"\\033[A\\033[A\")\n            print(f\"   Getting Shades [100%]\")\n        return shades\n\n    def _get_closest_shade(self, shades, current_shade, show_progress=False):\n        closest_shade = []\n        last_difference = 255\n        for sn, shade in enumerate(shades):\n            current_diff = 0\n            diff = []\n            avg_diff = 0\n            if len(closest_shade) == 0:\n                closest_shade = shade\n                continue\n            else:\n                diff = [abs(int(shade[i]) - int(current_shade[i]))\n                        for i in range(0, len(shade))]\n                avg_diff = sum(diff)/len(diff)\n            if avg_diff < last_difference:\n                closest_shade = shade\n                last_difference = avg_diff\n        return closest_shade\n\n    def cellshade(self, threshold, show_progress=False):\n        shades = self._get_avg_shades(threshold, show_progress)\n        # print(shades)\n        num_of_rows = len(self.matrix)\n        last_percent = -1\n        for rn, row in enumerate(self.matrix):\n            self.matrix[rn] = [self._get_closest_shade(\n                shades, self.matrix[rn, cn], show_progress) for cn in range(0, len(row))]\n\n            if last_percent != int(rn/num_of_rows*100) and show_progress:\n                if last_percent >= 0:\n                    print(\"\\033[A\\033[A\")\n                print(f\" Cell Shading [{int(rn/num_of_rows*100)}%]\")\n            last_percent = int(rn/num_of_rows*100)\n        if show_progress:\n            print(\"\\033[A\\033[A\")\n            print(f\" Cell Shading [100%]\")\n        return self\n\n\n    def downscale(self, pixel_size:int, show_progress=False):\n        num_of_rows = len(self.matrix)\n        last_percent = -1\n        ret_matrix = []\n        for rn, row in enumerate(self.matrix):\n            if rn%pixel_size == 0:\n                row_buffer = []\n                for cn, column in enumerate(row):\n                    if cn%pixel_size == 0:\n                        row_buffer.append(column)\n                ret_matrix.append(row_buffer)\n            if last_percent != int(rn/num_of_rows*100) and show_progress:\n                if last_percent >= 0:\n                    print(\"\\033[A\\033[A\")\n                print(f\" Downscaling [{int(rn/num_of_rows*100)}%]\")\n            last_percent = int(rn/num_of_rows*100)\n        if show_progress:\n            print(\"\\033[A\\033[A\")\n            print(f\" Downscaling [100%]\")\n        return ret_matrix\n\n    def mosaic(self, pixel_size:int, show_progress=False):\n        num_of_rows = len(self.matrix)\n        last_percent = -1\n        blur_matrix = self.downscale(pixel_size, show_progress)\n        for rn, row in enumerate(self.matrix):\n            for cn, column in enumerate(row):\n                self.matrix[rn, cn] = blur_matrix[math.floor(rn/pixel_size)][math.floor(cn/pixel_size)]\n            if last_percent != int(rn/num_of_rows*100) and show_progress:\n                if last_percent >= 0:\n                    print(\"\\033[A\\033[A\")\n                print(f\" Mosaic [{int(rn/num_of_rows*100)}%]\")\n            last_percent = int(rn/num_of_rows*100)\n        if show_progress:\n            print(\"\\033[A\\033[A\")\n            print(f\" Mosaic [100%]\")\n        return self\n\n    def contrast(self, percent, show_progress=False):\n        percent /= 100\n        num_of_rows = len(self.matrix)\n        last_percent = -1\n        for rn, row in enumerate(self.matrix):\n            self.matrix[rn] = [[(col_val + ((255 - float(col_val)) * percent) if col_val > 127.5 else col_val - (\n                (float(col_val)) * percent)) for col_val in column] for column in row]\n            if last_percent != int(rn/num_of_rows*100) and show_progress:\n                if last_percent >= 0:\n                    print(\"\\033[A\\033[A\")\n                print(f\" Contrasting Image [{int(rn/num_of_rows*100)}%]\")\n            last_percent = int(rn/num_of_rows*100)\n        if show_progress:\n            print(\"\\033[A\\033[A\")\n            print(f\" Contrasting Image [100%]\")\n        return self\n\n    def decontrast(self, percent, show_progress=False):\n        percent /= 100\n        num_of_rows = len(self.matrix)\n        last_percent = -1\n        for rn, row in enumerate(self.matrix):\n            self.matrix[rn] = [[(col_val - ((float(col_val) - 127.5) * percent) if col_val > 127.5 else col_val + (\n                (127.5 - float(col_val)) * percent)) for col_val in column] for column in row]\n\n            if last_percent != int(rn/num_of_rows*100) and show_progress:\n                if last_percent >= 0:\n                    print(\"\\033[A\\033[A\")\n                print(f\" Decontrasting Image [{int(rn/num_of_rows*100)}%]\")\n            last_percent = int(rn/num_of_rows*100)\n        if show_progress:\n            print(\"\\033[A\\033[A\")\n            print(f\" Decontrasting Image [100%]\")\n        return self\n\n    def mosaic_blur(self, itterations:int, intensity = 3, show_progress=False):\n        last_percent = -1\n        for i in range(2, itterations):\n            self.mosaic_screen(intensity, i, False)\n            if last_percent != int(i/itterations*100) and show_progress:\n                if last_percent >= 0:\n                    print(\"\\033[A\\033[A\")\n                print(f\" Mosaic Blur [{int(i/itterations*100)}%]\")\n            last_percent = int(i/itterations*100)\n        if show_progress:\n            print(\"\\033[A\\033[A\")\n            print(f\" Mosaic Blur [100%]\")\n        return self\n\n    def mosaic_screen(self, percent:int, pixel_size:int, show_progress=False):\n        percent /= 100\n        num_of_rows = len(self.matrix)\n        last_percent = -1\n        blur_matrix = self.downscale(pixel_size, show_progress=False)\n        for rn, row in enumerate(self.matrix):\n            for cn, column in enumerate(row):\n                for cvn, col_val in enumerate(column):\n                    #print(int(blur_matrix[math.floor(rn/intensity)][math.floor(cn/intensity)][cvn]) - int(col_val))\n                    self.matrix[rn, cn, cvn] = ((int(blur_matrix[math.floor(rn/pixel_size)][math.floor(cn/pixel_size)][cvn]*percent)) + int(col_val))/(1 + percent)\n            if last_percent != int(rn/num_of_rows*100) and show_progress:\n                if last_percent >= 0:\n                    print(\"\\033[A\\033[A\")\n                print(f\" Mosaic Screen [{int(rn/num_of_rows*100)}%]\")\n            last_percent = int(rn/num_of_rows*100)\n        if show_progress:\n            print(\"\\033[A\\033[A\")\n            print(f\" Mosaic Screen [100%]\")\n        return self\n    \n    def trippy_pixel(self, percent:int, pixel_size:int, show_progress=False):\n        percent /= 100\n        num_of_rows = len(self.matrix)\n        last_percent = -1\n        blur_matrix = self.downscale(pixel_size, show_progress=False)\n        for rn, row in enumerate(self.matrix):\n            for cn, column in enumerate(row):\n                for cvn, col_val in enumerate(column):\n                    #print(int(blur_matrix[math.floor(rn/intensity)][math.floor(cn/intensity)][cvn]) - int(col_val))\n                    self.matrix[rn, cn, cvn] += ((int(blur_matrix[math.floor(rn/pixel_size)][math.floor(cn/pixel_size)][cvn] * percent)) + int(col_val))/(1+percent)\n            if last_percent != int(rn/num_of_rows*100) and show_progress:\n                if last_percent >= 0:\n                    print(\"\\033[A\\033[A\")\n                print(f\" Trippy Blur [{int(rn/num_of_rows*100)}%]\")\n            last_percent = int(rn/num_of_rows*100)\n        if show_progress:\n            print(\"\\033[A\\033[A\")\n            print(f\" Trippy Blur [100%]\")\n        return self\n\n    def save(self, save_as: str):\n        save_image = Image.fromarray(self.matrix.astype(np.uint8))\n        save_image.save(save_as)\n        return self\n\n\n\n", "projects\\Python Image Processor\\root\\LICENSE": "MIT License\n\nCopyright (c) 2022 William A. Lim\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n", "projects\\Python Image Processor\\root\\main.py": "from image import ImageProcessor\n\nif __name__ == \"__main__\":\n    img = ImageProcessor(\"tests/Original.jpg\")\n    print(\"Processing...\")\n    img.mosaic_blur(10, 3, True)\\\n    .save(\"tests/Blur.jpg\")\\\n    .contrast(50, True)\\\n    .save(\"tests/Contrast.jpg\")\n    print(\"Done!\")", "projects\\Python Image Processor\\root\\README.md": "# Python Image Processor 0.2.1\n A python image matrix processor made using numpy and pillow.  This module features a saturate, desaturate, contrast, decontrast, mosaic, mosaic blur, black and white, and a cell shading filter.\n", "projects\\Python Image Processor\\root\\tests": {"projects\\Python Image Processor\\root\\tests\\Blur.jpg": "http://127.0.0.1:5000/static\\projects\\Python Image Processor\\root\\tests\\Blur.jpg", "projects\\Python Image Processor\\root\\tests\\Contrast.jpg": "http://127.0.0.1:5000/static\\projects\\Python Image Processor\\root\\tests\\Contrast.jpg", "projects\\Python Image Processor\\root\\tests\\Original.jpg": "http://127.0.0.1:5000/static\\projects\\Python Image Processor\\root\\tests\\Original.jpg"}}}}