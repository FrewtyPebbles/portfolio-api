{"root": {"projects\\Neat Object Notation\\root": {"projects\\Neat Object Notation\\root\\.gitignore": "/target\n", "projects\\Neat Object Notation\\root\\Cargo.lock": "# This file is automatically @generated by Cargo.\n# It is not intended for manual editing.\nversion = 3\n\n[[package]]\nname = \"Neat\"\nversion = \"0.2.0\"\ndependencies = [\n \"indexmap\",\n \"libc\",\n \"serde\",\n \"serde_json\",\n]\n\n[[package]]\nname = \"autocfg\"\nversion = \"1.1.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d468802bab17cbc0cc575e9b053f41e72aa36bfa6b7f55e3529ffa43161b97fa\"\n\n[[package]]\nname = \"hashbrown\"\nversion = \"0.12.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"8a9ee70c43aaf417c914396645a0fa852624801b24ebb7ae78fe8272889ac888\"\n\n[[package]]\nname = \"indexmap\"\nversion = \"1.9.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"10a35a97730320ffe8e2d410b5d3b69279b98d2c14bdb8b70ea89ecf7888d41e\"\ndependencies = [\n \"autocfg\",\n \"hashbrown\",\n]\n\n[[package]]\nname = \"itoa\"\nversion = \"1.0.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"4217ad341ebadf8d8e724e264f13e593e0648f5b3e94b3896a5df283be015ecc\"\n\n[[package]]\nname = \"libc\"\nversion = \"0.2.137\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"fc7fcc620a3bff7cdd7a365be3376c97191aeaccc2a603e600951e452615bf89\"\n\n[[package]]\nname = \"ryu\"\nversion = \"1.0.11\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"4501abdff3ae82a1c1b477a17252eb69cee9e66eb915c1abaa4f44d873df9f09\"\n\n[[package]]\nname = \"serde\"\nversion = \"1.0.147\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d193d69bae983fc11a79df82342761dfbf28a99fc8d203dca4c3c1b590948965\"\n\n[[package]]\nname = \"serde_json\"\nversion = \"1.0.87\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"6ce777b7b150d76b9cf60d28b55f5847135a003f7d7350c6be7a773508ce7d45\"\ndependencies = [\n \"indexmap\",\n \"itoa\",\n \"ryu\",\n \"serde\",\n]\n", "projects\\Neat Object Notation\\root\\Cargo.toml": "[package]\nname = \"Neat\"\nversion = \"0.2.0\"\nedition = \"2021\"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[dependencies]\nserde = \"1.0\"\nindexmap = \"1.9.1\"\nserde_json = {version = \"1.0\", features = [\"preserve_order\"]}\nlibc = \"0.2.137\"\n\n[lib]\nname = \"neat_lib\"\npath = \"src/lib.rs\"\ncrate-type = [\"dylib\"]", "projects\\Neat Object Notation\\root\\README.md": "# Neat Object Notation 0.3.1\n\n A smart, modular and readable configuration file format for complex multifile solutions.\n\n## Comments\n\n```\n| Any lines which are to be commented out must start with a pipe character.\n| The pipe must ALWAYS be at the beginning of the line for comments.\n```\n\n## Global Scope\n\n By default the global scope of a Neat config file is a dictionary, if you wish to specify otherwise you must put this somewhere in your .neat file on its own line\n\n```\n~list\n```\n\n## Labeled Structures\n\n```\n[This is where you write the key associated with your dictionary]\n\n\t\"This is a key to an inline dictionary\":{\"This is the key to an inline list\":()}\n\n| This [-] token denotes the end of a dictionary.\n[-]\n\n<This is where you write the key associated with your list>\n\n|\tThe line below is the 0th index of this labeled list and is a list with a single item,\n|\tThat single item is an empty dictionary\n\t({})\n\n| This <-> token denotes the end of a list.\n<->\n```\n\n## Unlabeled Structures\n\nIf you wish to create an unlabeled structure vertically you can do so like this:\n\n```\n~list\n\n{\n\t\"Some key\":29873198273\n}\n\n```\n\nAnother example:\n\n```\n<section name>\n\t{\n\t\t[inner section name]\n\t\t\t\"some key\": True\n\t\t[-]\n\t\t\"another key\": \"abc\"\n\t}\n<->\n```\n\n## Modules\n\nImporting only specific sections of a module:\n\n```\n| This file is called filename.neat\n<section name>\n\t{\n\t\t[inner section name]\n\t\t\t\"some key\": True\n\t\t[-]\n\t\t\"another key\": \"abc\"\n\t}\n<->\n```\n\n```\n|this is where we are importing the module\nmod filename : 'section name'.0.'inner section name'\n\n| Alternate syntax\n\n* foldername.filename : 'section name'.0.'inner section name'\n```\n\nImporting a whole module:\n\n```\n|this file is called module.neat\n[section]\n\t1:\"abc\"\n[-]\n```\n\n```\n| This is where we import module.neat\nmod module\n\n[another section]\n\t\"def\":2\n[-]\n\n| Result:\n| {\"module\":{\"section\":{\"1\":\"abc\"}},\"another section\":{\"def\":2}}\n```\n\n## Alias\n\nAliases can be used to add items to sections outside of that section and its parent.\nThe left hand side of the : is the alias name.  The right hand side of the : is the alias path.\n\n```\n<section name>\n\t{\n\t\t[inner section name]\n\t\t\t\"some key\": True\n\t\t[-]\n\t\t\"another key\": \"abc\"\n\t}\n<->\n\n| this is the alias declaration\nalias alias_name : [section name] 0 [inner section name]\n\n| the name of the alias, in this case alias_name, marks the start of an alias section.\nalias_name\n\t\"some other key\": false\n| The /-/ token marks the end of an alias section\n/-/\n\n| Result:\n| {\"section name\":[{\"inner section name\":{\"some key\":True,\"some other key\":False},\"another key\":\"abc\"}]}\n```\n", "projects\\Neat Object Notation\\root\\src": {"projects\\Neat Object Notation\\root\\src\\lib.rs": "pub mod neat;\n\nuse std::{collections::HashMap, ffi::{CString, CStr}};\n\nuse libc::c_char;\nuse neat::tokenizer::serialize;\nuse serde::Serialize;\nuse serde_json::value::Serializer;\n\nuse crate::neat::datatypes::VType;\n#[no_mangle]\npub extern fn load(file_path: *const c_char) -> *mut c_char {\n    let aliases: HashMap<String, Vec<VType>> = HashMap::new();\n\tlet mut c_string = String::new();\n\tunsafe {\n\t\tc_string = CStr::from_ptr(file_path).to_str().unwrap().to_string();\n\t}\n\tprintln!(\"{}\", c_string);\n    CString::new(\n        serialize(&c_string, &aliases)\n            .serialize(Serializer)\n            .unwrap()\n            .as_str()\n            .unwrap(),\n    )\n    .unwrap()\n    .into_raw()\n}\n", "projects\\Neat Object Notation\\root\\src\\main.rs": "use std::{io::{stdin, self}, env, collections::HashMap};\n\nuse neat::tokenizer::serialize;\nuse serde::Serialize;\nuse serde_json::value::Serializer;\n\nuse crate::neat::datatypes::VType;\n\npub mod neat;\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let aliases:HashMap<String, Vec<VType>> = HashMap::new();\n    println!(\"{}\", serialize(&args[1], &aliases).serialize(Serializer).unwrap().to_string());\n}\n", "projects\\Neat Object Notation\\root\\src\\neat": {"projects\\Neat Object Notation\\root\\src\\neat\\datatypes.rs": "use std::any::{TypeId};\n\nuse indexmap::IndexMap;\n\nuse serde::{Serialize, Serializer, ser::{SerializeMap, SerializeSeq}};\n\npub enum ScopeType {\n    None,\n    Literal,\n    List,\n    Struct,\n}\n\n#[derive(PartialEq)]\npub enum ValWrap {\n    None,\n    Keyword,\n    Literal,\n    StringSingle,\n    StringDouble,\n    Section,\n    ListSection,\n}\n#[derive(PartialEq, Debug, Clone)]\npub enum PTok {\n    SList,\n    EList,\n    SSection,\n    ESection,\n    SAlias,\n    EAlias,\n    ELine,\n    SLine,\n    Literal,\n    Keyword,\n    Delimeter,\n    Setter,\n    AutoInc,\n    Blank,\n    GlobalList,\n    GlobalDict,\n    Module(String, Vec<Vec<String>>)\n}\n\n#[derive(PartialEq, Debug, Clone)]\npub enum VType {\n    Blank,\n    Bool(bool),\n    Int(i64),\n    Float(f64),\n    String(String),\n    Alias(String),\n    Null,\n}\n\n#[derive(Debug, Clone)]\npub struct Token {\n    pub v_type: VType,\n    pub tok: PTok,\n}\n\npub struct Null {}\n\n#[derive(Eq, PartialEq, Hash, Debug, Clone)]\npub enum NDSKeyType {\n    Int(i64),\n    Str(String),\n    Bool(bool),\n    Null,\n    Blank\n}\n\nimpl From<i64> for NDSKeyType {\n    fn from(index: i64) -> Self {\n        return NDSKeyType::Int(index);\n    }\n}\nimpl From<String> for NDSKeyType {\n    fn from(index: String) -> Self {\n        return NDSKeyType::Str(index);\n    }\n}\nimpl From<Null> for NDSKeyType {\n    fn from(_: Null) -> Self {\n        return NDSKeyType::Null;\n    }\n}\nimpl From<bool> for NDSKeyType {\n    fn from(index: bool) -> Self {\n        return NDSKeyType::Bool(index);\n    }\n}\n\nimpl Into<i64> for NDSKeyType {\n    fn into(self) -> i64 {\n        if let NDSKeyType::Int(value) = self {\n\t\t\treturn value;\n\t\t}\n\t\telse {\n\t\t\treturn 0;\n\t\t}\n    }\n}\nimpl Into<String> for NDSKeyType {\n    fn into(self) -> String {\n        if let NDSKeyType::Str(value) = self{\n\t\t\treturn value;\n\t\t}\n\t\telse {\n\t\t\treturn String::new();\n\t\t}\n    }\n}\nimpl Into<Null> for NDSKeyType {\n    fn into(self) -> Null {\n        return Null {};\n    }\n}\nimpl Into<bool> for NDSKeyType {\n    fn into(self) -> bool {\n        if let NDSKeyType::Bool(value) = self{\n\t\t\treturn value;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n    }\n}\n\n#[derive(PartialEq, Debug, Clone)]\npub enum NDSType {\n    // NDSType stands for Node Datastructure Type\n    //\t The NDSType is the type of structure that the Node is holding\n    //\t and is used by member functions to decern how to access data\n    //\t within the node.\n    Hashmap(IndexMap<NDSKeyType, Box<SerializedNode>>),\n    List(Vec<Box<SerializedNode>>),\n    Int(i64),\n    Str(String),\n    Float(f64),\n    Bool(bool),\n    Null\n}\n\n#[derive(PartialEq, Debug, Clone)]\npub struct SerializedNode {\n    // See NDSType comments for info on how this works\n    pub value: NDSType,\n}\n\n//SERIALIZATION\nimpl Serialize for SerializedNode {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer\n    {\n        let typename = std::any::type_name::<S>();\n        if typename.contains(\"serde_json\") {\n            match self.value.clone() {\n                NDSType::Hashmap(val) => {\n                    let mut map = serializer.serialize_map(Some(val.len()))?;\n                    for (key, value) in val.iter() {\n                        match key {\n                            NDSKeyType::Int(kval) => {map.serialize_entry(kval, value)?;},\n                            NDSKeyType::Str(kval) => {map.serialize_entry(kval, value)?;},\n                            NDSKeyType::Bool(kval) => {},\n                            NDSKeyType::Null => {map.serialize_entry(&Option::<char>::None, value)?;},\n                            NDSKeyType::Blank => {},\n                        };\n                    }\n                    map.end()\n                },\n                NDSType::List(val) => {\n                    let mut seq = serializer.serialize_seq(Some(val.len()))?;\n                    for value in val.iter() {\n                        seq.serialize_element(value)?;\n                    }\n                    seq.end()\n                },\n                NDSType::Int(val) => {\n                    serializer.serialize_i64(val)\n                },\n                NDSType::Str(val) => {\n                    serializer.serialize_str(val.as_str())\n                },\n                NDSType::Float(val) => {\n                    serializer.serialize_f64(val)\n                },\n                NDSType::Bool(val) => {\n                    serializer.serialize_bool(val)\n                },\n                NDSType::Null => {\n                    serializer.serialize_none()\n                },\n            }\n        }\n        else {\n            match self.value.clone() {\n                NDSType::Hashmap(mut val) => {\n                    let mut map = serializer.serialize_map(Some(val.len()))?;\n                    for (key, value) in val.iter() {\n                        match key {\n                            NDSKeyType::Int(kval) => {map.serialize_entry(kval, value)?;},\n                            NDSKeyType::Str(kval) => {map.serialize_entry(kval, value)?;},\n                            NDSKeyType::Bool(kval) => {map.serialize_entry(kval, value)?;},\n                            NDSKeyType::Null => {map.serialize_entry(&Option::<char>::None, value)?;},\n                            NDSKeyType::Blank => {map.serialize_entry(&Option::<char>::None, value)?;},\n                        };\n                    }\n                    map.end()\n                },\n                NDSType::List(val) => {\n                    let mut seq = serializer.serialize_seq(Some(val.len()))?;\n                    for value in val.iter() {\n                        seq.serialize_element(value)?;\n                    }\n                    seq.end()\n                },\n                NDSType::Int(val) => {\n                    serializer.serialize_i64(val)\n                },\n                NDSType::Str(val) => {\n                    serializer.serialize_str(val.as_str())\n                },\n                NDSType::Float(val) => {\n                    serializer.serialize_f64(val)\n                },\n                NDSType::Bool(val) => {\n                    serializer.serialize_bool(val)\n                },\n                NDSType::Null => {\n                    serializer.serialize_none()\n                },\n            }\n        }\n        \n    }\n}\n\nimpl SerializedNode {\n    //Must use getters and setters to ensure heterogenious datatypes are accessed correctly.\n    // EX: Keys in a Hashmap may be of any type\n    //Also needs member functions for checking the type of a node.\n    fn at<T: Into<usize> + Into<i64> + Into<String> + Into<bool> + Into<Null> + From<i64> + From<String> + From<bool> + From<Null> + 'static>(\n        &self,\n        index: T,\n    ) -> Result<&Box<SerializedNode>, String> {\n        match &self.value {\n            NDSType::List(val) => {\n                return Ok(&val[<T as Into<usize>>::into(index)]);\n            }\n            NDSType::Hashmap(val) => {\n\t\t\t\tlet generic_t = TypeId::of::<T>();\n                if generic_t == TypeId::of::<String>() {\n\t\t\t\t\treturn Ok(&val[&NDSKeyType::from(<T as Into<String>>::into(index))]);\n\t\t\t\t}\n\t\t\t\telse if generic_t == TypeId::of::<bool>() {\n\t\t\t\t\treturn Ok(&val[&NDSKeyType::from(<T as Into<bool>>::into(index))]);\n\t\t\t\t}\n\t\t\t\telse if generic_t == TypeId::of::<i64>() {\n\t\t\t\t\treturn Ok(&val[&NDSKeyType::from(<T as Into<i64>>::into(index))]);\n\t\t\t\t}\n\t\t\t\telse if generic_t == TypeId::of::<Null>() {\n\t\t\t\t\treturn Ok(&val[&NDSKeyType::from(<T as Into<Null>>::into(index))]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn Err(String::from(\"i128, String, bool, datatypes::Null are the only compatable types with Hashmap Nodes\"));\n\t\t\t\t}\n            }\n            _ => {\n                return Err(String::from(\"Not an indexable type\"));\n            }\n        };\n    }\n}\n", "projects\\Neat Object Notation\\root\\src\\neat\\tokenizer.rs": "use std::{fs, path::{Path, PathBuf}, collections::HashMap};\n\nuse crate::neat::datatypes::VType;\n\nuse super::{\n    datatypes::{PTok, ScopeType, SerializedNode, Token, ValWrap},\n    treebuilder::build_tree,\n    typeconversion::determine_type,\n};\n\npub fn create_mod_token(raw_mod_string: String, origin_file_path:&str, alias_vec:&mut HashMap<String, Vec<VType>>) -> Box<Token> {\n    let mut filepath = PathBuf::from(&fs::canonicalize(Path::new(origin_file_path)).ok().unwrap());\n    {\n        let mut ans = filepath.ancestors();\n        ans.next();\n        filepath = PathBuf::from(ans.next().unwrap().to_str().unwrap());\n    }\n    let mut is_quoting = ' ';\n    let mut quote_buffer = String::new();\n    let mut path_buffer = String::new();\n    let mut is_mod = true;\n    let mut last_char = ' ';\n    let mut objects:Vec<Vec<String>> = vec![];\n    let mut object_buffer:Vec<String> = vec![];\n    for chr in raw_mod_string.chars() {\n        match chr {\n            '\"' => {\n                if is_quoting == '\"' {\n                    is_quoting = ' '\n                } else if is_quoting == ' ' {\n                    is_quoting = '\"';\n                } else {\n                    quote_buffer.push(chr);\n                }\n            }\n            '\\'' => {\n                if is_quoting == '\\'' {\n                    is_quoting = ' ';\n                } else if is_quoting == ' ' {\n                    is_quoting = '\\'';\n                } else {\n                    quote_buffer.push(chr);\n                }\n            }\n            '?' | ':' | '=' => {\n                if is_quoting == '\\'' {\n                    quote_buffer.push(chr);\n                } else if is_quoting == '\"' {\n                    quote_buffer.push(chr);\n                } else {\n                    is_mod = false;//marks the end of the mod path\n                    filepath.push(path_buffer.trim().clone());\n                    path_buffer = String::new()\n                }\n            }\n            '.' => {\n                if is_mod {\n                    if is_quoting == '\\'' {\n                        quote_buffer.push(chr);\n                    } else if is_quoting == '\"' {\n                        quote_buffer.push(chr);\n                    } else if last_char == '.' {\n                        let mut ans = filepath.ancestors();\n                        ans.next();\n                        filepath = PathBuf::from(ans.next().unwrap().to_str().unwrap());\n                    } else {\n                        filepath.push(path_buffer.trim().clone());\n                        path_buffer = String::new();\n                    }\n                } else {\n                    if is_quoting == '\\'' {\n                        quote_buffer.push(chr);\n                    } else if is_quoting == '\"' {\n                        quote_buffer.push(chr);\n                    } else {\n                        object_buffer.push(quote_buffer);\n                        quote_buffer = String::new();\n                    }\n                }\n            }\n            ',' => {\n                if is_mod {\n                    if is_quoting == '\\'' {\n                        quote_buffer.push(chr);\n                    } else if is_quoting == '\"' {\n                        quote_buffer.push(chr);\n                    }\n                } else {\n                    if is_quoting == '\\'' {\n                        quote_buffer.push(chr);\n                    } else if is_quoting == '\"' {\n                        quote_buffer.push(chr);\n                    } else {\n                        object_buffer.push(quote_buffer);\n                        objects.push(object_buffer);\n                        quote_buffer = String::new();\n                        object_buffer = vec![];\n                    }\n                }\n            }\n            _ => {\n                if is_quoting == '\\'' || is_quoting == '\"' {\n                    quote_buffer.push(chr);\n                } else {\n                    path_buffer.push(chr);\n                }\n            }\n        }\n        last_char = chr;\n    }\n    if is_mod {\n        filepath.push(path_buffer.trim().clone());\n    } else {\n        object_buffer.push(quote_buffer);\n        objects.push(object_buffer);\n    }\n    filepath.set_extension(\"neat\");\n    return Box::new(Token {\n        v_type: VType::Blank,\n        tok: PTok::Module(filepath.as_path().to_str().unwrap().to_string(), objects),\n    });\n}\n\npub fn create_alias_token(raw_alias_string: String, mut alias_vec:&mut HashMap<String, Vec<VType>>){\n    let mut alias_name = String::new();\n    let mut is_quoting = ' ';\n    let mut last_char = ' ';\n    let mut alias_name = String::new();\n    let mut is_lhs = true;\n    let mut quote_buffer = String::new();\n    let mut object_path:Vec<VType> = vec![];\n    for chr in raw_alias_string.chars() {\n        match chr {\n            '\"' => {\n                if is_quoting == '\"' {\n                    is_quoting = ' ';\n                    object_path.push(VType::String(quote_buffer.clone()));\n                    quote_buffer = String::new();\n                } else if is_quoting == ' ' {\n                    is_quoting = '\"';\n                } else {\n                    quote_buffer.push(chr);\n                }\n            }\n            '\\'' => {\n                if is_quoting == '\\'' {\n                    is_quoting = ' ';\n                    object_path.push(VType::String(quote_buffer.clone()));\n                    quote_buffer = String::new();\n                } else if is_quoting == ' ' {\n                    is_quoting = '\\'';\n                } else {\n                    quote_buffer.push(chr);\n                }\n            }\n            '['|'{' => {\n                if is_quoting == ' ' {\n                    is_quoting = '[';\n                } else {\n                    quote_buffer.push(chr);\n                }\n            }\n            ']'|'}' => {\n                if is_quoting == '[' {\n                    is_quoting = ' ';\n                    object_path.push(VType::String(quote_buffer.clone()));\n                    quote_buffer = String::new();\n                } else {\n                    quote_buffer.push(chr);\n                }\n            }\n            '<'|'(' => {\n                if is_quoting == ' ' {\n                    is_quoting = '<';\n                } else {\n                    quote_buffer.push(chr);\n                }\n            }\n            '>'|')' => {\n                if is_quoting == '<' {\n                    is_quoting = ' ';\n                    object_path.push(VType::String(quote_buffer.clone()));\n                    quote_buffer = String::new();\n                } else {\n                    quote_buffer.push(chr);\n                }\n            }\n            ' ' => {\n                is_lhs = false;\n                if is_quoting != ' ' {\n                    quote_buffer.push(chr);\n                } else if is_quoting == ' ' && quote_buffer.trim() != \"\" {\n                    if quote_buffer.chars().all(|charr| charr.is_numeric()) {\n                        object_path.push(VType::Int(quote_buffer.parse::<i64>().unwrap()));\n                        quote_buffer = String::new();\n                    } else if vec![\n                        \"true\",\n                        \"t\",\n                        \"yes\",\n                        \"y\",\n                        \"yup\",\n                        \"affirmative\",\n                        \"yep\",\n                        \"correct\",\n                        \"right\",\n                        \"positive\",\n                    ]\n                    .contains(&quote_buffer.clone().to_lowercase().as_str())\n                    {\n                        object_path.push(VType::Bool(true));\n                        quote_buffer = String::new();\n                    } else if vec![\n                        \"false\", \"f\", \"no\", \"n\", \"nope\", \"nada\", \"never\", \"not\", \"wrong\",\n                        \"negative\",\n                    ]\n                    .contains(&quote_buffer.clone().to_lowercase().as_str())\n                    {\n                        object_path.push(VType::Bool(false));\n                        quote_buffer = String::new();\n                    } else if vec![\n                        \"idk\",\n                        \"?\",\n                        \"null\",\n                        \"/\",\n                        \"na\",\n                        \"none\",\n                        \"untitled\",\n                        \"empty\",\n                        \"nonapplicable\",\n                    ]\n                    .contains(&quote_buffer.clone().to_lowercase().as_str())\n                    {\n                        object_path.push(VType::Null);\n                        quote_buffer = String::new();\n                    }\n                }\n            }\n            '\\t' => {\n                is_lhs = false;\n                if is_quoting != ' ' {\n                    quote_buffer.push(chr);\n                }\n            }\n            '=' | ':' => {\n                is_lhs = false;\n                if is_quoting != ' ' {\n                    quote_buffer.push(chr);\n                }\n            }\n            _ => {\n                if is_quoting != ' ' {\n                    quote_buffer.push(chr);\n                } else if is_lhs {\n                    alias_name.push(chr);\n                } else {\n                    quote_buffer.push(chr);\n                }\n            }\n        }\n        last_char = chr;\n    }\n    //println!(\"{}: {:?}\\n\\n\", alias_name,object_path);\n    alias_vec.insert(alias_name.clone(), object_path);\n}\n\npub fn serialize(file_path: &str, alias_vec:&HashMap<String, Vec<VType>>) -> Box<SerializedNode> {\n    let file_content = fs::read_to_string(file_path).unwrap();\n    let mut token_vec: Vec<Box<Token>> = vec![];\n    let mut val_wrap = ValWrap::None;\n    let scope_type_stack = vec![ScopeType::None];\n    //this acts as a buffer for the current token\n    let mut string_buffer = String::new();\n    let mut last_character = '\\t';\n    let mut is_dict = true;\n    let mut alias_list:HashMap<String, Vec<VType>> = alias_vec.clone();\n    for (ln, raw_line) in file_content.clone().split(\"\\n\").enumerate() {\n        let temp_line = format!(\"{} \", raw_line.trim());\n        let line = temp_line.as_str();\n        if line == \"\" || line.starts_with(\"|\") {\n            continue;\n        }\n        //Handle section/list enders\n        else if vec![\"[-] \", \"# \"].contains(&line) {\n            token_vec.push(Box::new(Token {\n                v_type: VType::Blank,\n                tok: PTok::ESection,\n            }));\n            continue;\n        } else if vec![\"<-> \", \"~ \"].contains(&line) {\n            token_vec.push(Box::new(Token {\n                v_type: VType::Blank,\n                tok: PTok::EList,\n            }));\n            continue;\n        } else if line.trim() == \"/-/\" {\n            token_vec.push(Box::new(Token {\n                v_type: VType::Blank,\n                tok: PTok::EAlias,\n            }));\n            continue;\n        } else if vec![\"< \", \"( \"].contains(&line) {\n            token_vec.push(Box::new(Token {\n                v_type: VType::Blank,\n                tok: PTok::SList,\n            }));\n            continue;\n        } else if vec![\"> \", \") \"].contains(&line) {\n            token_vec.push(Box::new(Token {\n                v_type: VType::Blank,\n                tok: PTok::EList,\n            }));\n            continue;\n        } else if vec![\"[ \", \"{ \"].contains(&line) {\n            token_vec.push(Box::new(Token {\n                v_type: VType::Blank,\n                tok: PTok::SSection,\n            }));\n            continue;\n        } else if vec![\"] \", \"} \"].contains(&line) {\n            token_vec.push(Box::new(Token {\n                v_type: VType::Blank,\n                tok: PTok::ESection,\n            }));\n            continue;\n        } else if vec![\n            \"~list \", \"~l \", \"~<> \", \"~> \", \"~< \", \"~vec \", \"~vector \", \"~v \", \"~array \", \"~a \",\n            \"~() \", \"~) \", \"~( \",\n        ]\n        .contains(&line)\n        {\n            is_dict = false;\n            continue;\n        } else if vec![\n            \"~dict \",\n            \"~section \",\n            \"~sect \",\n            \"~sec \",\n            \"~s \",\n            \"~d \",\n            \"~[] \",\n            \"~{} \",\n            \"~{ \",\n            \"~} \",\n            \"~[ \",\n            \"~] \",\n            \"~section \",\n        ]\n        .contains(&line)\n        {\n            is_dict = true;\n            continue;\n        } else if line.starts_with(\"mod \") {\n            token_vec.push(create_mod_token(\n                line.strip_prefix(\"mod \")\n                    .unwrap()\n                    .trim()\n                    .replace(\"\\t\", \"\"),\n                    file_path.clone(),\n                    &mut alias_list\n            ));\n            continue;\n        } else if line.starts_with(\"* \") {\n            token_vec.push(create_mod_token(\n                line.strip_prefix(\"* \")\n                    .unwrap()\n                    .trim()\n                    .replace(\"\\t\", \"\"),\n                    file_path.clone(),\n                    &mut alias_list\n            ));\n            continue;\n        } else if line.starts_with(\"alias \") {\n            create_alias_token(\n                line.strip_prefix(\"alias \")\n                    .unwrap()\n                    .trim()\n                    .replace(\"\\t\", \"\"),\n                    &mut alias_list\n                );\n            continue;\n        } else if line.starts_with(\"@ \") {\n            create_alias_token(\n                line.strip_prefix(\"@ \")\n                    .unwrap()\n                    .trim()\n                    .replace(\"\\t\", \"\"),\n                    &mut alias_list\n                );\n            continue;\n        } else if alias_list.keys().collect::<Vec<&String>>().contains(&&raw_line.trim().to_string()) {\n            token_vec.push(Box::new(Token {\n                v_type: VType::Alias(raw_line.trim().to_string().clone()),\n                tok: PTok::SAlias,\n            }));\n            continue;\n        }\n        //\n\n        //LINE LOOP\n        for (cn, curr_character) in line.clone().chars().enumerate() {\n            if curr_character ==' ' && last_character == '-' {\n                string_buffer.pop();\n            }\n            if val_wrap == ValWrap::None {\n                if curr_character.is_alphanumeric()\n                    || curr_character == '?'\n                    || curr_character == '/'\n                    || curr_character == '.'\n                {\n                    string_buffer.push(curr_character.clone());\n                    continue;\n                } else if string_buffer != \"\" {\n                    if vec![\n                        \"true\",\n                        \"t\",\n                        \"yes\",\n                        \"y\",\n                        \"yup\",\n                        \"affirmative\",\n                        \"yep\",\n                        \"correct\",\n                        \"right\",\n                        \"positive\",\n                    ]\n                    .contains(&string_buffer.clone().to_lowercase().as_str())\n                    {\n                        token_vec.push(Box::new(Token {\n                            v_type: VType::Bool(true),\n                            tok: PTok::Literal,\n                        }));\n                    } else if vec![\n                        \"false\", \"f\", \"no\", \"n\", \"nope\", \"nada\", \"never\", \"not\", \"wrong\",\n                        \"negative\",\n                    ]\n                    .contains(&string_buffer.clone().to_lowercase().as_str())\n                    {\n                        token_vec.push(Box::new(Token {\n                            v_type: VType::Bool(false),\n                            tok: PTok::Literal,\n                        }));\n                    } else if vec![\n                        \"idk\",\n                        \"?\",\n                        \"null\",\n                        \"/\",\n                        \"na\",\n                        \"none\",\n                        \"untitled\",\n                        \"empty\",\n                        \"nonapplicable\",\n                    ]\n                    .contains(&string_buffer.clone().to_lowercase().as_str())\n                    {\n                        token_vec.push(Box::new(Token {\n                            v_type: VType::Null,\n                            tok: PTok::Literal,\n                        }));\n                    } else if string_buffer.chars().enumerate().all(|(ilcn, il_char)| il_char.is_numeric() || (ilcn == 0 && il_char == '-')) {\n                        token_vec.push(Box::new(Token {\n                            v_type: determine_type(VType::Int(0), string_buffer.clone()),\n                            tok: PTok::Literal,\n                        }));\n                    } else if string_buffer\n                        .chars().enumerate().all(|(ilcn, il_char)| il_char.is_numeric() || (ilcn == 0 && il_char == '-') || il_char=='.')\n                    {\n                        token_vec.push(Box::new(Token {\n                            v_type: determine_type(VType::Float(0.0), string_buffer.clone()),\n                            tok: PTok::Literal,\n                        }));\n                    } else {\n                        token_vec.push(Box::new(Token {\n                            v_type: VType::Alias(string_buffer.clone()),\n                            tok: PTok::Literal,\n                        }));\n                    }\n                    string_buffer = String::new();\n                }\n                match curr_character {\n                    '[' => val_wrap = ValWrap::Section,\n                    '<' => val_wrap = ValWrap::ListSection,\n                    '(' => {\n                        if token_vec.last().clone().unwrap().tok == PTok::Setter {\n                            let new_tok = Box::new(Token {\n                                v_type: token_vec[token_vec.len() - 1].v_type.clone(),\n                                tok: PTok::SList,\n                            });\n                            token_vec.pop();\n                            token_vec.push(new_tok);\n                        } else {\n                            token_vec.push(Box::new(Token {\n                                v_type: VType::Blank,\n                                tok: PTok::SList,\n                            }));\n                        }\n                    }\n                    ')' => {\n                        token_vec.push(Box::new(Token {\n                            v_type: VType::Blank,\n                            tok: PTok::EList,\n                        }));\n                    }\n                    '{' => {\n                        if token_vec.last().clone().unwrap().tok == PTok::Setter {\n                            let new_tok = Box::new(Token {\n                                v_type: token_vec[token_vec.len() - 1].v_type.clone(),\n                                tok: PTok::SSection,\n                            });\n                            token_vec.pop();\n                            token_vec.push(new_tok);\n                        } else {\n                            token_vec.push(Box::new(Token {\n                                v_type: VType::Blank,\n                                tok: PTok::SSection,\n                            }));\n                        }\n                    }\n                    '}' => {\n                        token_vec.push(Box::new(Token {\n                            v_type: VType::Blank,\n                            tok: PTok::ESection,\n                        }));\n                    }\n                    '\"' => {\n                        val_wrap = ValWrap::StringDouble;\n                    }\n                    '\\'' => {\n                        val_wrap = ValWrap::StringSingle;\n                    }\n                    ',' => {}\n                    '-' => {string_buffer.push(curr_character)}\n                    ':' | '=' => {\n                        let new_tok = Box::new(Token {\n                            v_type: token_vec[token_vec.len() - 1].v_type.clone(),\n                            tok: PTok::Setter,\n                        });\n                        token_vec.pop();\n                        token_vec.push(new_tok);\n                    }\n                    ' ' => {\n                        if last_character == '-' {\n                            string_buffer.pop();\n                            token_vec.push(Box::new(Token {\n                                v_type: VType::Blank,\n                                tok: PTok::AutoInc,\n                            }));\n                        }\n                    }\n                    _ => {\n                        // Handle Keywords\n                    }\n                }\n            } else {\n                match val_wrap {\n                    ValWrap::Section => {\n                        if curr_character == ']' {\n                            //end section\n                            if string_buffer == \"-\" {\n                                token_vec.push(Box::new(Token {\n                                    v_type: VType::Blank,\n                                    tok: PTok::ESection,\n                                }));\n                            } else {\n                                token_vec.push(Box::new(Token {\n                                    v_type: VType::String(string_buffer.clone()),\n                                    tok: PTok::SSection,\n                                }));\n                            }\n                            string_buffer = String::new();\n                            val_wrap = ValWrap::None;\n                        } else {\n                            string_buffer.push(curr_character.clone());\n                        }\n                    }\n                    ValWrap::ListSection => {\n                        if curr_character == '>' {\n                            //end section\n                            if string_buffer == \"-\" {\n                                token_vec.push(Box::new(Token {\n                                    v_type: VType::Blank,\n                                    tok: PTok::ESection,\n                                }));\n                            } else {\n                                token_vec.push(Box::new(Token {\n                                    v_type: VType::String(string_buffer.clone()),\n                                    tok: PTok::SList,\n                                }));\n                            }\n                            string_buffer = String::new();\n                            val_wrap = ValWrap::None;\n                        } else {\n                            string_buffer.push(curr_character.clone());\n                        }\n                    }\n                    ValWrap::StringSingle => {\n                        if curr_character == '\\'' {\n                            //end section\n                            token_vec.push(Box::new(Token {\n                                v_type: VType::String(string_buffer.clone()),\n                                tok: PTok::Literal,\n                            }));\n                            string_buffer = String::new();\n                            val_wrap = ValWrap::None;\n                        } else {\n                            string_buffer.push(curr_character.clone());\n                        }\n                    }\n                    ValWrap::StringDouble => {\n                        if curr_character == '\"' {\n                            //end section\n                            token_vec.push(Box::new(Token {\n                                v_type: VType::String(string_buffer.clone()),\n                                tok: PTok::Literal,\n                            }));\n                            string_buffer = String::new();\n                            val_wrap = ValWrap::None;\n                        } else {\n                            string_buffer.push(curr_character.clone());\n                        }\n                    }\n                    _ => {}\n                }\n            }\n            last_character = curr_character.clone();\n        }\n    }\n    //println!(\"{:?}\", token_vec);\n    return build_tree(token_vec, is_dict, file_path, &alias_list)\n}\n", "projects\\Neat Object Notation\\root\\src\\neat\\treebuilder.rs": "use std::{collections::HashMap, slice::Iter};\n\nuse indexmap::IndexMap;\n\nuse crate::neat::datatypes::VType;\n\nuse super::{datatypes::{Token, SerializedNode, NDSType, PTok, NDSKeyType}, tokenizer::serialize};\n\nfn alias_get(alias:String, aliases:HashMap<String, Vec<VType>>, mut curr_scope:&mut Vec<Box<SerializedNode>>){\n\tlet curr_a_list = aliases[&alias].clone();\n\t//println!(\"{:?}\", curr_a_list);\n\tfor curr_key in curr_a_list.iter() {\n\t\tmatch &curr_scope[0].value {\n\t\t\tNDSType::Hashmap(val) => {\n\t\t\t\tmatch curr_key {\n\t\t\t\t\tVType::Bool(v) => {\n\t\t\t\t\t\tcurr_scope[0] = val[&NDSKeyType::Bool(v.clone())].clone();\n\t\t\t\t\t},\n\t\t\t\t\tVType::Int(v) => {\n\t\t\t\t\t\tcurr_scope[0] = val[&NDSKeyType::Int(v.clone())].clone();\n\t\t\t\t\t},\n\t\t\t\t\tVType::String(v) => {\n\t\t\t\t\t\tprintln!(\"{:?}, k={}\",val, v);\n\t\t\t\t\t\tcurr_scope[0] = val[&NDSKeyType::Str(v.clone())].clone();\n\t\t\t\t\t},\n\t\t\t\t\tVType::Null => {\n\t\t\t\t\t\tcurr_scope[0] = val[&NDSKeyType::Null].clone();\n\t\t\t\t\t},\n\t\t\t\t\t_ => {}\n\t\t\t\t}\n\t\t\t},\n\t\t\tNDSType::List(val) => {\n\t\t\t\tmatch curr_key {\n\t\t\t\t\tVType::Int(v) => {\n\t\t\t\t\t\tcurr_scope[0] = val[*v as usize].clone();\n\t\t\t\t\t},\n\t\t\t\t\t_ => {}\n\t\t\t\t}\n\t\t\t},\n\t\t\t_ => {},\n\t\t}\n\t}\n}\n\nfn alias_set(aliases:Vec<VType>, mut curr_scope:&mut Box<SerializedNode>, set_scope:SerializedNode) {\n\t\n\tfn search(scope_ref: &mut SerializedNode, mut curr_a_list:Iter<VType>, set_scope:SerializedNode){\n\t\tlet mut a_list = VType::Blank;\n\t\tif !curr_a_list.clone().next().is_none() {\n\t\t\ta_list = curr_a_list.next().unwrap().clone();\n\t\t}\n\t\telse {\n\t\t\t*scope_ref = set_scope;\n\t\t\treturn;\n\t\t}\n\t\tmatch &mut scope_ref.value {\n\t\t\tNDSType::Hashmap(val) => {\n\t\t\t\tmatch a_list {\n\t\t\t\t\tVType::Bool(v) => {\n\t\t\t\t\t\tsearch(&mut val[&NDSKeyType::Bool(v.clone())], curr_a_list, set_scope);\n\t\t\t\t\t},\n\t\t\t\t\tVType::Int(v) => {\n\t\t\t\t\t\tsearch(&mut val[&NDSKeyType::Int(v.clone())], curr_a_list, set_scope);\n\t\t\t\t\t},\n\t\t\t\t\tVType::String(v) => {\n\t\t\t\t\t\tsearch(&mut val[&NDSKeyType::Str(v.clone())], curr_a_list, set_scope);\n\t\t\t\t\t},\n\t\t\t\t\tVType::Null => {\n\t\t\t\t\t\tsearch(&mut val[&NDSKeyType::Null], curr_a_list, set_scope);\n\t\t\t\t\t},\n\t\t\t\t\t_ => {}\n\t\t\t\t}\n\t\t\t},\n\t\t\tNDSType::List(val) => {\n\t\t\t\tmatch a_list {\n\t\t\t\t\tVType::Int(v) => {\n\t\t\t\t\t\tsearch(&mut val[v as usize], curr_a_list, set_scope);\n\t\t\t\t\t},\n\t\t\t\t\t_ => {}\n\t\t\t\t}\n\t\t\t},\n\t\t\t_ => {},\n\t\t}\n\t}\n\n\tlet mut curr_a_list = aliases.iter();\n\n\tsearch(&mut curr_scope, curr_a_list, set_scope);\n\t//println!(\"{:?}\", curr_scope);\n}\n\npub fn build_tree(token_list: Vec<Box<Token>>, is_dict:bool, file_path:&str, alias_vec:&HashMap<String, Vec<VType>>) -> Box<SerializedNode> {\n\tlet mut tree_stack:Vec<Box<SerializedNode>> = vec![];\n\tlet mut key_stack:Vec<NDSKeyType> = vec![NDSKeyType::Blank];\n\tlet mut aliases:HashMap<String, Vec<VType>> = alias_vec.clone();\n\tlet mut current_used_stack = &mut tree_stack;\n\tlet mut alias_scope:(Vec<Vec<VType>>, Vec<Vec<Box<SerializedNode>>>) = (vec![], vec![]);// if not empty then use this scope instead\n\tlet mut num_stack:Vec<i64> = vec![-1];\n\tif is_dict {\n\t\tlet inner_hm:IndexMap<NDSKeyType, Box<SerializedNode>> = IndexMap::new();\n\t\tcurrent_used_stack.push(Box::new(SerializedNode { value: NDSType::Hashmap(inner_hm) }));\n\t}\n\telse {\n\t\tlet inner_vec:Vec<Box<SerializedNode>> = Vec::new();\n\t\tcurrent_used_stack.push(Box::new(SerializedNode { value: NDSType::List(inner_vec) }));\n\t}\n\n\tfor (tn, tok) in token_list.iter().enumerate() {\n\t\tlet curr_tok = *tok.clone();\n\n\t\tmatch curr_tok.tok {\n\t\t\tPTok::SList => {\n\t\t\t\tmatch curr_tok.v_type {\n\t\t\t\t\tVType::Blank => {\n\t\t\t\t\t\tkey_stack.push(NDSKeyType::Blank);\n\t\t\t\t\t},\n\t\t\t\t\tVType::Bool(val) => {\n\t\t\t\t\t\tkey_stack.push(NDSKeyType::Bool(val));\n\t\t\t\t\t},\n\t\t\t\t\tVType::Int(val) => {\n\t\t\t\t\t\tkey_stack.push(NDSKeyType::Int(val));\n\t\t\t\t\t},\n\t\t\t\t\tVType::Float(_) => {},\n\t\t\t\t\tVType::String(val) => {\n\t\t\t\t\t\tkey_stack.push(NDSKeyType::Str(val));\n\t\t\t\t\t},\n\t\t\t\t\tVType::Null => {\n\t\t\t\t\t\tkey_stack.push(NDSKeyType::Null);\n\t\t\t\t\t},\n\t\t\t\t\tVType::Alias(_) => todo!()\n\t\t\t\t}\n\t\t\t\tlet inner_vec:Vec<Box<SerializedNode>> = Vec::new();\n\t\t\t\tcurrent_used_stack.push(Box::new(SerializedNode { value: NDSType::List(inner_vec) }))\n\t\t\t},\n\t\t\tPTok::EList => {\n\t\t\t\tlet stack_len = current_used_stack.len();\n\t\t\t\tif stack_len > 1 {\n\t\t\t\t\tlet new_value = Box::new(*current_used_stack[stack_len-1].clone());\n\t\t\t\t\tmatch &mut current_used_stack[stack_len - 2].value {\n\t\t\t\t\t\t\n\t\t\t\t\t\tNDSType::List(vector) =>{\n\t\t\t\t\t\t\tvector.push(new_value);\n\t\t\t\t\t\t\tkey_stack.pop();\n\t\t\t\t\t\t\tcurrent_used_stack.pop();\n\t\t\t\t\t\t},\n\t\t\t\t\t\tNDSType::Hashmap(hashmap) =>{\n\t\t\t\t\t\t\thashmap.insert(key_stack.last().unwrap().clone(), new_value);\n\t\t\t\t\t\t\tkey_stack.pop();\n\t\t\t\t\t\t\tcurrent_used_stack.pop();\n\t\t\t\t\t\t},\n\t\t\t\t\t\t_ => {}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tPTok::SSection => {\n\t\t\t\tmatch curr_tok.v_type {\n\t\t\t\t\tVType::Blank => {\n\t\t\t\t\t\tkey_stack.push(NDSKeyType::Blank);\n\t\t\t\t\t},\n\t\t\t\t\tVType::Bool(val) => {\n\t\t\t\t\t\tkey_stack.push(NDSKeyType::Bool(val));\n\t\t\t\t\t},\n\t\t\t\t\tVType::Int(val) => {\n\t\t\t\t\t\tkey_stack.push(NDSKeyType::Int(val));\n\t\t\t\t\t},\n\t\t\t\t\tVType::Float(_) => {},\n\t\t\t\t\tVType::String(val) => {\n\t\t\t\t\t\tkey_stack.push(NDSKeyType::Str(val));\n\t\t\t\t\t},\n\t\t\t\t\tVType::Null => key_stack.push(NDSKeyType::Null),\n\t\t\t\t\tVType::Alias(val) => {}\n\t\t\t\t}\n\t\t\t\tnum_stack.push(-1);\n\t\t\t\tlet inner_hm:IndexMap<NDSKeyType, Box<SerializedNode>> = IndexMap::new();\n\t\t\t\tcurrent_used_stack.push(Box::new(SerializedNode { value: NDSType::Hashmap(inner_hm) }));\n\t\t\t},\n\t\t\tPTok::ESection => {\n\t\t\t\tlet stack_len = current_used_stack.len();\n\t\t\t\tif stack_len > 1 {\n\t\t\t\t\tlet new_value = Box::new(*current_used_stack[stack_len-1].clone());\n\t\t\t\t\tmatch &mut current_used_stack[stack_len - 2].value {\n\t\t\t\t\t\t\n\t\t\t\t\t\tNDSType::List(vector) =>{\n\t\t\t\t\t\t\tif key_stack.last().unwrap().clone() == NDSKeyType::Blank {\n\t\t\t\t\t\t\t\tvector.push(new_value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tlet inner_hm:IndexMap<NDSKeyType, Box<SerializedNode>> = IndexMap::new();\n\t\t\t\t\t\t\t\tlet mut new_hm = Box::new(SerializedNode { value: NDSType::Hashmap(inner_hm) });\n\t\t\t\t\t\t\t\tmatch &mut new_hm.value {\n\t\t\t\t\t\t\t\t\tNDSType::Hashmap(hm) => {\n\t\t\t\t\t\t\t\t\t\thm.insert(key_stack.last().unwrap().clone(), new_value);\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t_ => {\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tvector.push(new_hm);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tNDSType::Hashmap(hashmap) =>{\n\t\t\t\t\t\t\thashmap.insert(key_stack.last().unwrap().clone(), new_value);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t},\n\t\t\t\t\t\t_ => {}\n\t\t\t\t\t}\n\t\t\t\t\tkey_stack.pop();\n\t\t\t\t\tcurrent_used_stack.pop();\n\t\t\t\t}\n\t\t\t\tnum_stack.pop();\n\t\t\t},\n\t\t\tPTok::Setter => {\n\t\t\t\tmatch curr_tok.v_type {\n\t\t\t\t\tVType::Blank => key_stack.push(NDSKeyType::Null),\n\t\t\t\t\tVType::Bool(val) => key_stack.push(NDSKeyType::Bool(val)),\n\t\t\t\t\tVType::Int(val) => {\n\t\t\t\t\t\tlet num_stack_len = num_stack.len();\n\t\t\t\t\t\tnum_stack[num_stack_len - 1] = val.clone();\n\t\t\t\t\t\tkey_stack.push(NDSKeyType::Int(val));\n\t\t\t\t\t},\n\t\t\t\t\tVType::String(val) => key_stack.push(NDSKeyType::Str(val)),\n\t\t\t\t\tVType::Null => key_stack.push(NDSKeyType::Null),\n\t\t\t\t\tVType::Float(_) => {\n\t\t\t\t\t\t//add an error handling system\n\t\t\t\t\t\teprintln!(\"Error: Float is not a valid key type.\")\n\t\t\t\t\t},\n\t\t\t\t\tVType::Alias(val) => todo!()\n\t\t\t\t}\n\t\t\t},\n\t\t\tPTok::Literal => {\n\t\t\t\t//if the last token is a setter then make it a single hashed item\n\t\t\t\tlet tlist_len = token_list.len();\n\t\t\t\tlet stack_len = current_used_stack.len();\n\t\t\t\tlet last_tok = token_list[tlist_len - 2].clone();\n\t\t\t\tif tn > 1 {\n\t\t\t\t\tif tlist_len > 1 && token_list[tn - 1].tok == PTok::Setter {\n\t\t\t\t\t\tmatch &mut current_used_stack[stack_len-1].value {\n\t\t\t\t\t\t\tNDSType::Hashmap(hm) => {\n\t\t\t\t\t\t\t\tmatch curr_tok.v_type {\n\t\t\t\t\t\t\t\t\tVType::Blank => {},\n\t\t\t\t\t\t\t\t\tVType::Bool(val) => {\n\t\t\t\t\t\t\t\t\t\thm.insert(key_stack.last().unwrap().clone(), Box::new(SerializedNode { value: NDSType::Bool(val) }));\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tVType::Int(val) => {\n\t\t\t\t\t\t\t\t\t\thm.insert(key_stack.last().unwrap().clone(), Box::new(SerializedNode { value: NDSType::Int(val) }));\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tVType::Float(val) => {\n\t\t\t\t\t\t\t\t\t\thm.insert(key_stack.last().unwrap().clone(), Box::new(SerializedNode { value: NDSType::Float(val) }));\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tVType::String(val) => {\n\t\t\t\t\t\t\t\t\t\thm.insert(key_stack.last().unwrap().clone(), Box::new(SerializedNode { value: NDSType::Str(val) }));\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tVType::Null => {\n\t\t\t\t\t\t\t\t\t\thm.insert(key_stack.last().unwrap().clone(), Box::new(SerializedNode { value: NDSType::Null }));\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tVType::Alias(_) => todo!()\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tkey_stack.pop();\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuniv => {\n\t\t\t\t\t\t\t\teprintln!(\"Error: Attempted to supply a key inside a list. {:?}\", univ);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if tlist_len > 1 && token_list[tn - 1].tok == PTok::AutoInc {\n\t\t\t\t\t\tmatch &mut current_used_stack[stack_len-1].value {\n\t\t\t\t\t\t\tNDSType::Hashmap(hm) => {\n\t\t\t\t\t\t\t\tmatch curr_tok.v_type {\n\t\t\t\t\t\t\t\t\tVType::Blank => {},\n\t\t\t\t\t\t\t\t\tVType::Bool(val) => {\n\t\t\t\t\t\t\t\t\t\thm.insert(NDSKeyType::Int(num_stack.last().unwrap().clone()), Box::new(SerializedNode { value: NDSType::Bool(val) }));\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tVType::Int(val) => {\n\t\t\t\t\t\t\t\t\t\thm.insert(NDSKeyType::Int(num_stack.last().unwrap().clone()), Box::new(SerializedNode { value: NDSType::Int(val) }));\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tVType::Float(val) => {\n\t\t\t\t\t\t\t\t\t\thm.insert(NDSKeyType::Int(num_stack.last().unwrap().clone()), Box::new(SerializedNode { value: NDSType::Float(val) }));\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tVType::String(val) => {\n\t\t\t\t\t\t\t\t\t\thm.insert(NDSKeyType::Int(num_stack.last().unwrap().clone()), Box::new(SerializedNode { value: NDSType::Str(val) }));\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tVType::Null => {\n\t\t\t\t\t\t\t\t\t\thm.insert(NDSKeyType::Int(num_stack.last().unwrap().clone()), Box::new(SerializedNode { value: NDSType::Null }));\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tVType::Alias(_) => todo!()\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t//key_stack.pop();\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuniv => {\n\t\t\t\t\t\t\t\teprintln!(\"Error: Attempted to supply autoincrement inside a list. {:?}\", univ);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tmatch &mut current_used_stack[stack_len-1].value {\n\t\t\t\t\t\t\tNDSType::List(vec) => {\n\t\t\t\t\t\t\t\tmatch curr_tok.v_type {\n\t\t\t\t\t\t\t\t\tVType::Blank => {},\n\t\t\t\t\t\t\t\t\tVType::Bool(val) => {\n\t\t\t\t\t\t\t\t\t\tvec.push(Box::new(SerializedNode { value: NDSType::Bool(val) }));\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tVType::Int(val) => {\n\t\t\t\t\t\t\t\t\t\tvec.push(Box::new(SerializedNode { value: NDSType::Int(val) }));\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tVType::Float(val) => {\n\t\t\t\t\t\t\t\t\t\tvec.push(Box::new(SerializedNode { value: NDSType::Float(val) }));\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tVType::String(val) => {\n\t\t\t\t\t\t\t\t\t\tvec.push(Box::new(SerializedNode { value: NDSType::Str(val) }));\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tVType::Null => {\n\t\t\t\t\t\t\t\t\t\tvec.push(Box::new(SerializedNode { value: NDSType::Null }));\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tVType::Alias(_) => todo!()\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tNDSType::Hashmap(hm) => {\n\t\t\t\t\t\t\t\tmatch curr_tok.v_type {\n\t\t\t\t\t\t\t\t\tVType::Blank => {},\n\t\t\t\t\t\t\t\t\tVType::Bool(val) => {\n\t\t\t\t\t\t\t\t\t\thm.insert(key_stack.last().unwrap().clone(), Box::new(SerializedNode { value: NDSType::Bool(val) }));\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tVType::Int(val) => {\n\t\t\t\t\t\t\t\t\t\thm.insert(key_stack.last().unwrap().clone(), Box::new(SerializedNode { value: NDSType::Int(val) }));\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tVType::Float(val) => {\n\t\t\t\t\t\t\t\t\t\thm.insert(key_stack.last().unwrap().clone(), Box::new(SerializedNode { value: NDSType::Float(val) }));\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tVType::String(val) => {\n\t\t\t\t\t\t\t\t\t\thm.insert(key_stack.last().unwrap().clone(), Box::new(SerializedNode { value: NDSType::Str(val) }));\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tVType::Null => {\n\t\t\t\t\t\t\t\t\t\thm.insert(key_stack.last().unwrap().clone(), Box::new(SerializedNode { value: NDSType::Null }));\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tVType::Alias(_) => todo!()\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tkey_stack.pop();\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuniv => {\n\t\t\t\t\t\t\t\teprintln!(\"Error: Key for {:?} supplied in a list. {:?}\", curr_tok.v_type, univ);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//else append it to the top list\n\t\t\t},\n\t\t\tPTok::Module(path, objects) => {\n\t\t\t\tlet ts_last_ind = current_used_stack.len()-1;\n\t\t\t\tlet module = serialize(path.as_str(), alias_vec);\n\t\t\t\tlet mut current_key = path.split(\"\\\\\").collect::<Vec<&str>>().last().unwrap().strip_suffix(\".neat\").unwrap().to_string();\n\t\t\t\tif objects.len() == 0 {\n\t\t\t\t\tmatch &mut current_used_stack[ts_last_ind].value {\n\t\t\t\t\t\tNDSType::Hashmap(val) => {val.insert(NDSKeyType::Str(current_key), module.clone());},\n\t\t\t\t\t\tNDSType::List(val) => {val.push(module.clone());},\n\t\t\t\t\t\t_ => {}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor object_path in objects.iter() {\n\t\t\t\t\tlet mut current_ds = module.clone();\n\t\t\t\t\tcurrent_key = path.split(\"\\\\\").collect::<Vec<&str>>().last().unwrap().strip_suffix(\".neat\").unwrap().to_string();\n\t\t\t\t\tfor object in object_path.iter() {\n\t\t\t\t\t\tcurrent_key = object.to_string();\n\t\t\t\t\t\tcurrent_ds = match current_ds.value {\n\t\t\t\t\t\t\tNDSType::Hashmap(val_in) => val_in[&NDSKeyType::Str(current_key.clone())].clone(),\n\t\t\t\t\t\t\tNDSType::List(val_in) => val_in[current_key.parse::<usize>().unwrap()].clone(),\n\t\t\t\t\t\t\tNDSType::Int(val_in) => Box::new(SerializedNode{value:NDSType::Int(val_in)}),\n\t\t\t\t\t\t\tNDSType::Str(val_in) => Box::new(SerializedNode{value:NDSType::Str(val_in)}),\n\t\t\t\t\t\t\tNDSType::Float(val_in) => Box::new(SerializedNode{value:NDSType::Float(val_in)}),\n\t\t\t\t\t\t\tNDSType::Bool(val_in) => Box::new(SerializedNode{value:NDSType::Bool(val_in)}),\n\t\t\t\t\t\t\tNDSType::Null => Box::new(SerializedNode{value:NDSType::Null}),\n\t\t\t\t\t\t};\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tmatch &mut current_used_stack[ts_last_ind].value {\n\t\t\t\t\t\tNDSType::Hashmap(val) => {val.insert(NDSKeyType::Str(current_key), current_ds);},\n\t\t\t\t\t\tNDSType::List(val) => {val.push(current_ds.clone());},\n\t\t\t\t\t\t_ => {}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tPTok::SAlias => {\n\t\t\t\tmatch curr_tok.v_type {\n\t\t\t\t\tVType::Alias(val) => {\n\t\t\t\t\t\tlet alias_scope_1_len = alias_scope.1.len();\n\t\t\t\t\t\tif alias_scope_1_len != 0 {\n\t\t\t\t\t\t\talias_scope.1.push(alias_scope.1[alias_scope_1_len - 1].clone());\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\talias_scope.1.push(vec![tree_stack[0].clone()]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\talias_scope.0.push(aliases[&val].clone());\n\t\t\t\t\t\tcurrent_used_stack = &mut alias_scope.1[alias_scope_1_len];\n\t\t\t\t\t\talias_get(val, aliases.clone(), &mut current_used_stack);\n\t\t\t\t\t},\n\t\t\t\t\t_ => {}\n\t\t\t\t}\n\t\t\t},\n\t\t\tPTok::EAlias => {\n\t\t\t\tprintln!(\"{:?}\", alias_scope);\n\t\t\t\tlet mut alias_scope_1_len = alias_scope.1.len();\n\t\t\t\tlet mut alias_scope_0_len = alias_scope.0.len();\n\t\t\t\tlet mut sets_scope = *alias_scope.1[alias_scope_1_len - 1][0].clone();\n\t\t\t\tlet mut curr_aliases = alias_scope.0[alias_scope_0_len - 1].clone();\n\t\t\t\talias_scope.0.pop();\n\t\t\t\talias_scope.1.pop();\n\t\t\t\talias_scope_1_len = alias_scope.1.len();\n\t\t\t\talias_scope_0_len = alias_scope.0.len();\n\t\t\t\tif alias_scope_1_len != 0 {\n\t\t\t\t\tcurrent_used_stack = &mut alias_scope.1[alias_scope_1_len - 1];\n\t\t\t\t} else {\n\t\t\t\t\tcurrent_used_stack = &mut tree_stack;\n\t\t\t\t}\n\t\t\t\talias_set(curr_aliases, &mut current_used_stack[0], sets_scope);\n\t\t\t\t//println!(\"alias[0] {:?}\",alias_scope.1[0]);\n\t\t\t\t\n\t\t\t}\n\t\t\tPTok::AutoInc => {\n\t\t\t\tlet num_stack_len = num_stack.len();\n\t\t\t\tnum_stack[num_stack_len - 1] += 1;\n\t\t\t}\n\t\t\t_ => {}\n\t\t}\n\t}\n\t\n\treturn tree_stack[0].clone();\n}", "projects\\Neat Object Notation\\root\\src\\neat\\typeconversion.rs": "use super::datatypes::VType;\n\npub fn determine_type(v_type: VType, raw_type: String) -> VType {\n    let mut ret_type: VType = VType::Blank;\n    //println!(\"{}\", raw_type);\n    match v_type {\n        VType::Int(_) => {\n\t\t\tret_type = VType::Int(raw_type.parse::<i64>().unwrap());\n\t\t},\n        VType::Float(_) => {\n\t\t\tret_type = VType::Float(raw_type.parse::<f64>().unwrap());\n\t\t},\n        _ => todo!()\n    }\n\n    return ret_type;\n}\n"}, "projects\\Neat Object Notation\\root\\src\\neat.rs": "pub mod tokenizer;\npub mod treebuilder;\npub mod datatypes;\npub mod typeconversion;"}, "projects\\Neat Object Notation\\root\\tests": {"projects\\Neat Object Notation\\root\\tests\\class.neat": "[grades]\n\t<William>\n\t\t\"C\"\n\t\t\"F\"\n\t\t\"B\"\n\t<->\n\t<Ludia>\n\t\t\"A\"\n\t\t\"A\"\n\t\t\"B+\"\n\t<->\n[-]\n\n[trash]\n\t- \"yuhdcihufcehusdcvfhksfd\"\n\t- \"cljlmjicdamjli\"\n\t- -21.323254\n[-]", "projects\\Neat Object Notation\\root\\tests\\config.neat": "~dict\nmod class : 'grades'\n\n<William's classes>\n\t\"CPSC DATASTRUCTURES\"\n\t\"CPSC DATABASES AND FILESTRUCTURES\"\n<->\n<Ludia's classes>\n\t\"CHEMISTRY\"\n\t\"PYTHON/JAVA\"\n<->\n\n[names/ages]\n\t\"William\":22\n\t\"Ludia\":21\n[-]\n\nalias n_a : [names/ages]\n\nn_a\n\t\"Jef\":49\n\t[Mary]\n\t\t\"abc\":22\n\t[-]\n\talias mar : [Mary]\n\tmar\n\t\t\"def\":123\n\t/-/\n/-/\n", "projects\\Neat Object Notation\\root\\tests\\output.json": "{\n  \"grades\": {\n    \"William\": [\n      \"C\",\n      \"F\",\n      \"B\"\n    ],\n    \"Ludia\": [\n      \"A\",\n      \"A\",\n      \"B+\"\n    ]\n  },\n  \"trash\": {\n    \"0\": \"abc\",\n    \"1\": \"abc\",\n    \"2\": \"abc\",\n    \"3\": \"abc\",\n    \"4\": \"abc\"\n  },\n  \"William's classes\": [\n    \"CPSC DATASTRUCTURES\",\n    \"CPSC DATABASES AND FILESTRUCTURES\"\n  ],\n  \"Ludia's classes\": [\n    \"CHEMISTRY\",\n    \"PYTHON/JAVA\"\n  ],\n  \"names/ages\": {\n    \"William\": 22,\n    \"Ludia\": 21,\n    \"jef\": 49\n  }\n}"}}}}