{"root": {"projects\\Earwig Web Framework\\root": {"projects\\Earwig Web Framework\\root\\.gitattributes": "# Auto detect text files and perform LF normalization\n* text=auto\n", "projects\\Earwig Web Framework\\root\\.gitignore": "#sourcefiles\n*.html\n*.ear\n*.css\n*.json\n*.js\n.vs/\n.gitignore", "projects\\Earwig Web Framework\\root\\earwig.py": "from contextlib import redirect_stdout\nfrom io import StringIO\nimport os\nimport re\nimport textwrap\nimport threading\nfrom werkzeug.wrappers import Request, Response\nfrom urllib.parse import unquote_plus as URLDECODEPERCENT\nfrom werkzeug.utils import send_from_directory\nfrom werkzeug.serving import run_simple\nfrom werkzeug.datastructures import Headers\n\n#EARWIG FILES\nfrom libs.earwigUtils import *\nfrom libs.earwigParser import parse_EAR_to_string\n\n#EARWIG MODULES\nfrom libs.projectModules.htmlconstructor import *\nfrom libs.projectModules.accountManager import *\n\n#SQL ALCHEMY\nfrom sqlalchemy import create_engine, Column, Integer, String, select, UniqueConstraint\nfrom sqlalchemy.orm import sessionmaker, declarative_base\nfrom sqlalchemy.sql import exists\n\n\n\n#TODO\n#\n# #\n#\n#\n##############################################\n# GLOBAL VARS (nessicary for request system)\n##############################################\n\ncompiledCode = {}\nmoduleCache = {}\nVERSION_NUMBER = \"0.12.2\"\nUniversal = {}\nAuthTokens = {}\nearwigPages = {}\n\n#parse settings file\nrequestMimeType = ''\nsetting = {}\nroutingPath = {}\nforbiddenExtensions = []\nheaders = Headers()\n\n\n######################################\n# SETTINGS PARSER\n######################################\n\nwith open('settings.EWS') as settingsFile:\n\tsettingsLines = settingsFile.read().splitlines()\n\tlinenum = 0\n\tfor line in settingsLines:\n\t\tlinenum += 1\n\t\tif line == \"\":\n\t\t\tcontinue\n\t\telif line[0] == '!':\n\t\t\tforbiddenExtensions.append(line[1:])\n\t\telif not line.startswith(\"/!/\"):\n\t\t\tsettingPair = line.split('=')\n\t\t\tif line.startswith('ip')\\\n\t\t\tor line.startswith('port')\\\n\t\t\tor line.startswith('devmode')\\\n\t\t\tor line.startswith('engineDBType')\\\n\t\t\tor line.startswith('engineDBUsername')\\\n\t\t\tor line.startswith('engineDBPassword')\\\n\t\t\tor line.startswith('engineDBIp')\\\n\t\t\tor line.startswith('engineDBPort')\\\n\t\t\tor line.startswith('engineDBname'):\n\t\t\t\tif line.startswith('devmode'):\n\t\t\t\t\tsetting[settingPair[0]] = True if settingPair[1].upper() == \"TRUE\" else False\n\t\t\t\telse:\n\t\t\t\t\tsetting[settingPair[0]] = settingPair[1]\n\t\t\telif line.startswith('~'):\n\t\t\t\troutingPath[''] = settingPair[1]\n\t\t\telif line.startswith('@'):\n\t\t\t\tsetting['_boot_'] = line[1:]\n\t\t\telif '~' in line:\n\t\t\t\tLRside = line.split('~', 1)\n\t\t\t\tif '[' in LRside[1] or '{' in LRside[1]:\n\t\t\t\t\tsetting[LRside[0]] = json.loads(LRside[1])\n\t\t\t\telif LRside[1] == \"true\" or LRside[1] == \"false\":\n\t\t\t\t\tsetting[LRside[0]] = bool(LRside[1])\n\t\t\t\telif LRside[1].replace(\".\",\"\",1).replace(\"-\",\"\",1).isdigit():\n\t\t\t\t\tif '.' in LRside[1]:\n\t\t\t\t\t\tsetting[LRside[0]] = float(LRside[1])\n\t\t\t\t\telse:\n\t\t\t\t\t\tsetting[LRside[0]] = int(LRside[1])\n\t\t\t\telse:\n\t\t\t\t\tif '\"' not in LRside[1][0]:\n\t\t\t\t\t\tFatalERROR(\"settings\", \"Expected opening \\\", none provided.  String type assumed.\", linenum)\n\t\t\t\t\tif '\"' not in LRside[1][-1]:\n\t\t\t\t\t\tFatalERROR(\"settings\", \"Expected closing \\\", none provided.  String type expected.\", linenum)\n\t\t\t\t\tsetting[LRside[0]] = LRside[1][1:-1]\n\t\t\telse:\n\t\t\t\troutingPath[settingPair[0]] = settingPair[1]\nglobalEW = {}\nglobalEW[\"EWcompiledCode\"] = compiledCode\nglobalEW[\"EWmoduleCache\"] = moduleCache\nglobalEW[\"EWUniversal\"] = Universal\nglobalEW[\"EWAuthTokens\"] = AuthTokens\nglobalEW[\"EWearwigPages\"] = earwigPages\nglobalEW[\"EWsetting\"] = setting\nglobalEW[\"EWroutingPath\"] = routingPath\nglobalEW[\"EWforbiddenExtensions\"] = forbiddenExtensions\n\nEW_SQLACCESSdns = \"\"\nif 'engineDBUsername' in setting.keys():\n\tif setting['engineDBType'] == \"sqlite\":\n\t\tEW_SQLACCESSdns = f\"{setting['engineDBUsername'] if 'engineDBUsername' in setting.keys() else ''}{':' + setting['engineDBPassword'] if 'engineDBPassword' in setting.keys() else ''}@{setting['engineDBIp'] if 'engineDBIp' in setting.keys() else setting['ip']}:{setting['engineDBPort'] if 'engineDBPort' in setting.keys() else setting['port']}\"\nelse:\n\tsetting['engineDBType'] = 'sqlite'\n\nengine = create_engine(\n\tf\"{setting['engineDBType']}://{EW_SQLACCESSdns}/{'EWEngine.db' if 'engineDBname' not in setting.keys() else setting['engineDBname']}\",\n    future=True\n)\n\nSession = sessionmaker(\n\tfuture=True,\n\tbind=engine\n)\n\nEWEngineBase = declarative_base()\n\nclass EWRoute(EWEngineBase):\n\t__tablename__ = \"ewRoute\"\n\t\n\tid = Column(Integer, primary_key=True)\n\troute = Column(String, nullable=False)\n\tpath = Column(String, nullable=False)\n\t__table_args__ = (UniqueConstraint('route'),)\n\n\nwith engine.begin() as con:\n\tEWEngineBase.metadata.create_all(con)\n\nfor key, val in routingPath.items():\n\twith Session.begin() as session:\n\t\trouteExists = session.query(exists().where(EWRoute.route == key)).scalar()\n\tif routeExists == False:\n\t\twith Session.begin() as session:\n\t\t\t_SETingroute = EWRoute(route=key, path=val)\n\t\t\tsession.add(_SETingroute)\n\t\t\tsession.commit()\n\t\t\tsession.refresh(_SETingroute)\n\telse:\n\t\twith Session.begin() as session:\n\t\t\tsession.query(EWRoute).filter(EWRoute.route==key).update({'path':val})\n\t\t\tsession.commit()\n\ndef EW_routePath(_route):\n\twith Session.begin() as session:\n\t\tstatement = select(EWRoute.path).filter_by(route=_route)\n\t\treturn session.execute(statement).one()[0]\n\n###########################\n# UTILS\n###########################\n\n#http settings modifiers\ndef mime_type(mime: str):\n\tif mime.lower() == \"json\":\n\t\tglobalEW[\"requestMimeType\"] = 'text/json'\n\telif mime.lower() == \"html\":\n\t\tglobalEW[\"requestMimeType\"] = 'text/html'\n\telif mime.lower() == \"css\":\n\t\tglobalEW[\"requestMimeType\"] = 'text/css'\n\telif mime.lower() == \"js\" or mime.lower() == \"javascript\":\n\t\tglobalEW[\"requestMimeType\"] = 'text/javascript'\n\telif mime.lower() == \"wasm\":\n\t\tglobalEW[\"requestMimeType\"] = 'application/wasm'\n\telse:\n\t\tglobalEW[\"requestMimeType\"] = mime\n\treturn globalEW[\"requestMimeType\"]\n\ndef set_headers(headerDict:dict = {}):\n\tfor key, val in headerDict.items():\n\t\tglobalEW[\"EWheaders\"].set(key, val)\n\treturn globalEW[\"EWheaders\"]\n\n#setting modifiers\ndef set_setting(_setting:str, _newvalue):\n\tsetting[_setting] = _newvalue\n\treturn _newvalue\n\ndef set_route(_route:str, _path:str):\n\twith Session.begin() as session:\n\t\tif not session.query(session.query(EWRoute.id).filter_by(route=_route).exists()).scalar():\n\t\t\tnewroute = EWRoute(route=_route, path=_path)\n\t\t\tsession.add(newroute)\n\t\t\tsession.flush()\n\t\t\tsession.refresh(newroute)\n\t\telse:\n\t\t\tsession.query(EWRoute).filter_by(route=_route).update({'path':_path})\n\t\t\tsession.commit()\n\treturn (_route, _path)\n\ndef delete_route(_routeOrPath:str, _isRoute: bool = True) -> bool:\n\twith Session.begin() as session:\n\t\tif _isRoute:\n\t\t\ttry:\n\t\t\t\tsession.query(EWRoute).filter_by(route = _routeOrPath).delete()\n\t\t\t\tsession.commit()\n\t\t\t\treturn True\n\t\t\texcept:\n\t\t\t\treturn False\n\t\telse:\n\t\t\ttry:\n\t\t\t\tif session.query(EWRoute.id).filter_by(path = _routeOrPath).first() is not None:\n\t\t\t\t\tsession.query(EWRoute).filter_by(path = _routeOrPath).delete()\n\t\t\t\t\tsession.commit()\n\t\t\t\t\treturn True\n\t\t\t\treturn False\n\t\t\texcept:\n\t\t\t\treturn False\n\ndef append_setting(_setting:str, _appendvalue):\n\ttry:\n\t\tsetting[_setting].append(_appendvalue)\n\t\treturn setting[_setting]\n\texcept:\n\t\treturn False\n\ndef delete_setting(_setting:str) -> bool:\n\ttry:\n\t\tdel setting[_setting]\n\t\treturn True\n\texcept:\n\t\treturn False\n\ndef pop_setting(_setting, num:int = False):\n\ttry:\n\t\tif num == False:\n\t\t\tsetting[_setting].pop()\n\t\telse:\n\t\t\tsetting[_setting].pop(num)\n\t\treturn setting[_setting]\n\texcept:\n\t\treturn False\n\ndef renderPagePython(filename: str, fileContent, R_get, R_post, recompile):\n\t#FRAMEWORK VARS\n\t_BASE_URL = globalEW[\"ew_BASE_URL\"]\n\t_FULL_URL = globalEW[\"ew_FULL_URL\"]\n\t_PATH_URL = globalEW[\"ew_PATH_URL\"]\n\t_ORIGIN = globalEW[\"ew_REQUEST_ORIGIN\"]\n\t_COOKIES = globalEW[\"ew_REQUEST_COOKIES\"]\n\t_MIME_TYPE = globalEW[\"EWheaders\"]\n\t#\n\tcompiledHTML=\"\"\n\textensionStr = filename.split('.')[1]\n\tparsedSource = \"\"\n\tif extensionStr == \"ear\":\n\t\tparsedSource = textwrap.dedent(parse_EAR_to_string(filename))\n\telif extensionStr == \"py\":\n\t\tpyfile = open(filename)\n\t\tparsedSource = pyfile.read()\n\t\tpyfile.close()\n\tif recompile:\n\t\tprint(f\"EARWIG -{' DEV -' if setting['devmode'] else ''} [FILE \\\"{filename}\\\"] Recompiling source\")\n\tif recompile or setting[\"devmode\"]:\n\t\ttfname = f\"{filename}tmp\" if setting['devmode'] else ''\n\t\tif setting['devmode']:\n\t\t\ttempfile = open(tfname, 'w')\n\t\t\ttempfile.write(parsedSource)\n\t\t\ttempfile.close()\n\t\tglobalEW[\"EWcompiledCode\"][filename] = compile(parsedSource, tfname, \"exec\")\n\t\tif setting['devmode']:\n\t\t\tthreading.Thread(target=lambda:os.remove(tfname), daemon=True).start()\n\tf = StringIO()\n\twith redirect_stdout(f):\n\t\texec(globalEW[\"EWcompiledCode\"][filename])\n\tcompiledHTML = f.getvalue()\n\treturn compiledHTML\n\n############################\n# REQUESTS\n############################\n\n@Request.application\ndef application(request):\n\t#FRAMEWORK VARIABLES\n\tglobalEW[\"ew_BASE_URL\"] = request.root_url\n\tglobalEW[\"ew_FULL_URL\"] = request.base_url\n\tglobalEW[\"EWheaders\"] = Headers()\n\tglobalEW[\"ew_PATH_URL\"] = request.path\n\tglobalEW[\"ew_REQUEST_ORIGIN\"] = request.remote_addr\n\tglobalEW[\"ew_REQUEST_COOKIES\"] = request.cookies\n\tif request.method == 'POST':\n\t\tglobalEW[\"requestMimeType\"] = ''\n\t\turlVars = {}\n\t\tpostVars = request.form\n\t\tpostVars = {**postVars, **request.headers}\n\t\tpostVars = {**postVars, **request.files}\n\t\turlSlug = request.path[1:]\n\t\trender=\"\"\n\t\tif '.' not in request.path:\n\t\t\tglobalEW[\"requestMimeType\"] = 'text/html'\n\t\t\trawURLVars = []\n\t\t\tif '?' in request.url:\n\t\t\t\trawURLVars = request.full_path.split('?', 1)[1].split('&')\n\t\t\tfor i in range(0, len(rawURLVars)):\n\t\t\t\tdata = rawURLVars[i].split('=')\n\t\t\t\turlVars[data[0]] = URLDECODEPERCENT(data[1])\n\t\t\tif EW_routePath(urlSlug)  not in globalEW[\"EWearwigPages\"]:\n\t\t\t\tglobalEW[\"EWearwigPages\"][EW_routePath(urlSlug)] = open(EW_routePath(urlSlug), 'r').read()\n\t\t\t\trender = f\"\"\"{renderPagePython(EW_routePath(urlSlug),\n\t\t\t\t\t\t\tglobalEW[\"EWearwigPages\"][EW_routePath(urlSlug)],\n\t\t\t\t\t\t\tR_get=urlVars, R_post=postVars, recompile=True)}\"\"\"\n\t\t\telif globalEW[\"EWearwigPages\"][EW_routePath(urlSlug)] != open(EW_routePath(urlSlug), 'r').read():\n\t\t\t\tglobalEW[\"EWearwigPages\"][EW_routePath(urlSlug)] = open(EW_routePath(urlSlug), 'r').read()\n\t\t\t\trender = f\"\"\"{renderPagePython(EW_routePath(urlSlug),\n\t\t\t\t\t\t\tglobalEW[\"EWearwigPages\"][EW_routePath(urlSlug)],\n\t\t\t\t\t\t\tR_get=urlVars, R_post=postVars, recompile=True)}\"\"\"\n\t\t\telse:\n\t\t\t\tglobalEW[\"EWearwigPages\"][EW_routePath(urlSlug)] = open(EW_routePath(urlSlug), 'r').read()\n\t\t\t\trender = f\"\"\"{renderPagePython(EW_routePath(urlSlug),\n\t\t\t\t\t\t\tglobalEW[\"EWearwigPages\"][EW_routePath(urlSlug)],\n\t\t\t\t\t\t\tR_get=urlVars, R_post=postVars, recompile=False)}\"\"\"\n\t\telif check_forbidden(request.path.rsplit('.', 1)[1], forbiddenExtensions):\n\t\t\tif request.path.endswith(\".js\"):\n\t\t\t\tglobalEW[\"requestMimeType\"] = 'text/javascript'\n\t\t\tif request.path.endswith(\".css\"):\n\t\t\t\tglobalEW[\"requestMimeType\"] = 'text/css'\n\t\t\tif request.path.endswith(\".json\"):\n\t\t\t\tglobalEW[\"requestMimeType\"] = 'text/json'\n\t\t\tif request.path.endswith(\".wasm\"):\n\t\t\t\tglobalEW[\"requestMimeType\"] = 'application/wasm'\n\t\t\t\tprint(request.path.rsplit('/', 1)[0][1:] + request.path.rsplit('/', 1)[1])\n\t\t\t\treturn send_from_directory(request.path.rsplit('/', 1)[0][1:], request.path.rsplit('/', 1)[1])\n\t\t\trender = f\"{open(request.path.split('/', 1)[1], 'r').read()}\"\n\t\treturn Response(render, mimetype=globalEW[\"requestMimeType\"], headers=globalEW[\"EWheaders\"])\n\telse:\n\t\tglobalEW[\"requestMimeType\"] = ''\n\t\turlVars = {}\n\t\turlSlug = request.path[1:]\n\t\trender=\"\"\n\t\tif '.' not in request.path:\n\t\t\tglobalEW[\"requestMimeType\"] = 'text/html'\n\t\t\trawURLVars = []\n\t\t\tif '?' in request.url:\n\t\t\t\trawURLVars = request.full_path.split('?', 1)[1].split('&')\n\t\t\tfor i in range(0, len(rawURLVars)):\n\t\t\t\tdata = rawURLVars[i].split('=')\n\t\t\t\turlVars[data[0]] = URLDECODEPERCENT(data[1])\n\t\t\tif EW_routePath(urlSlug)  not in globalEW[\"EWearwigPages\"]:\n\t\t\t\tglobalEW[\"EWearwigPages\"][EW_routePath(urlSlug)] = open(EW_routePath(urlSlug), 'r').read()\n\t\t\t\trender = f\"\"\"{renderPagePython(EW_routePath(urlSlug),\n\t\t\t\t\t\t\tglobalEW[\"EWearwigPages\"][EW_routePath(urlSlug)],\n\t\t\t\t\t\t\tR_get=urlVars, R_post={}, recompile=True)}\"\"\"\n\t\t\telif globalEW[\"EWearwigPages\"][EW_routePath(urlSlug)] != open(EW_routePath(urlSlug), 'r').read():\n\t\t\t\tglobalEW[\"EWearwigPages\"][EW_routePath(urlSlug)] = open(EW_routePath(urlSlug), 'r').read()\n\t\t\t\trender = f\"\"\"{renderPagePython(EW_routePath(urlSlug),\n\t\t\t\t\t\t\tglobalEW[\"EWearwigPages\"][EW_routePath(urlSlug)],\n\t\t\t\t\t\t\tR_get=urlVars, R_post={}, recompile=True)}\"\"\"\n\t\t\telse:\n\t\t\t\tglobalEW[\"EWearwigPages\"][EW_routePath(urlSlug)] = open(EW_routePath(urlSlug), 'r').read()\n\t\t\t\trender = f\"\"\"{renderPagePython(EW_routePath(urlSlug),\n\t\t\t\t\t\t\tglobalEW[\"EWearwigPages\"][EW_routePath(urlSlug)],\n\t\t\t\t\t\t\tR_get=urlVars, R_post={}, recompile=False)}\"\"\"\n\t\telif check_forbidden(request.path.rsplit('.', 1)[1], forbiddenExtensions):\n\t\t\tif request.path.endswith(\".js\"):\n\t\t\t\tglobalEW[\"requestMimeType\"] = 'text/javascript'\n\t\t\tif request.path.endswith(\".css\"):\n\t\t\t\tglobalEW[\"requestMimeType\"] = 'text/css'\n\t\t\tif request.path.endswith(\".json\"):\n\t\t\t\tglobalEW[\"requestMimeType\"] = 'text/json'\n\t\t\tif request.path.endswith(\".wasm\"):\n\t\t\t\tglobalEW[\"requestMimeType\"] = 'application/wasm'\n\t\t\t\tprint(request.path.rsplit('/', 1)[0][1:] + request.path.rsplit('/', 1)[1])\n\t\t\t\treturn send_from_directory(request.path.rsplit('/', 1)[0][1:], request.path.rsplit('/', 1)[1])\n\t\t\trender = f\"{open(request.path.split('/', 1)[1], 'r').read()}\"\n\t\treturn Response(render, mimetype=globalEW[\"requestMimeType\"], headers=globalEW[\"EWheaders\"])\n\n#######################################\n# SERVER STARTUP\n#######################################\n\nif __name__ == \"__main__\":#execute server\n\t#display server parameters\n\tprint(f\"\\n----\\nEARWIG -{' DEV -' if setting['devmode'] else ''} [PORT { 8000 if setting['port'] == 'default' else int(setting['port'])}] Starting server...\")\n\tprint(\"\\nSettings:\")\n\t\n\tfor settingKey in setting.keys():\n\t\tprint(f\"\\t- {settingKey}: {setting[settingKey]}\")\n\t\n\tprint(\"\\nForbidden Extensions:\")\n\t\n\tfor forbidden in forbiddenExtensions:\n\t\tprint(f\"\\t- {forbidden}\")\n\n\tprint(\"\\nEWS Routes:\")\n\n\tfor routingKey in routingPath.keys():\n\t\tprint(f\"\\t- {routingKey if routingKey != '' else '~'}: {routingPath[routingKey]}\")\n\t\n\tprint(f\"\\nEARWIG -{' DEV -' if setting['devmode'] else ''} [PORT { 8000 if setting['port'] == 'default' else int(setting['port'])}] Running boot script...\\n\")\n\t\n\texec(open(setting['_boot_']).read())\n\t\n\tprint(f\"\\nEARWIG -{' DEV -' if setting['devmode'] else ''} [PORT { 8000 if setting['port'] == 'default' else int(setting['port'])}] Server started.\\n\")\n\t#run the server\n\trun_simple(setting[\"ip\"], int(setting['port']), application)\n\t#closing msg\n\tprint(f\"\\nEARWIG -{' DEV -' if setting['devmode'] else ''} [PORT { 8000 if setting['port'] == 'default' else int(setting['port'])}] Server closed.\\n\")", "projects\\Earwig Web Framework\\root\\favicon.ico": "", "projects\\Earwig Web Framework\\root\\libs": {"projects\\Earwig Web Framework\\root\\libs\\earwigParser.py": "import subprocess\nimport platform\n\ndef parse_EAR_to_string(filename: str) -> str:\n\tprint(f\"FILE: {filename}\")\n\toutput = \"\"\n\tplatform_name = platform.system()\n\tif platform_name.startswith('Windows'):\n\t\toutput = subprocess.getoutput(f'libs/ETE.exe {filename} \\'debug:true,\\'')\n\telif platform_name.startswith('Linux'):\n\t\toutput = subprocess.getoutput(f'libs/ETE {filename} \\'debug:true,\\'')\n\treturn str(output)", "projects\\Earwig Web Framework\\root\\libs\\earwigUtils.py": "#This file contains Helper functions for earwig.py\n\ndef check_forbidden(fileEx, forbiddenExtensions):\n\tif fileEx in forbiddenExtensions:\n\t\treturn False\n\treturn True\n\ndef FatalERROR(type, msg, linenum = \"?\"):\n\tif type == \"settings\":\n\t\tprint(f\"\\nEARWIG - ! - [ERROR line:{linenum}] {msg}\")\n\t\tprint(f\"FORCE EXITING [type {type}]: Fatal error.\")\n\t\texit()", "projects\\Earwig Web Framework\\root\\libs\\parser": {"projects\\Earwig Web Framework\\root\\libs\\parser\\ETE": "Cannot render binaries with UTF-8 characters.", "projects\\Earwig Web Framework\\root\\libs\\parser\\ETE.exe": "Cannot render binaries with UTF-8 characters."}, "projects\\Earwig Web Framework\\root\\libs\\projectModules": {"projects\\Earwig Web Framework\\root\\libs\\projectModules\\accountManager.py": "import json\nimport sqlite3\nfrom cryptography.fernet import Fernet\nimport hashlib\n\nACCOUNT_MANAGER_VERSION = \"0.1.0\"\n\n# TODO\n\"\"\"\n\t#\tImplement support for other sql dialects\n\n\"\"\"\n# END TODO\n\nclass SymmetricAuthTokens(object):\n\t\"\"\"\n\n\n\t\tBrief:\n\t\t\n\t\t\tObject for handling auth-tokens and login-logout functionality.\n\t\n\n\t\tVerbose:\n\t\n\t\t\tUses asymmetric encryption and SHA-512 hashing to ensure that tokens and login credentials are secure and protected against leaks.  Tokens use an identifier and token pair system to match client tokens to their respected keys with a hashed identifier that is on both the client and database.\n\t\t\\n\\n\\n\n\t\t\"\"\"\n\tdef __init__(self, identifier:str, dbName:str=\"Accounts\", accountTableName:str=\"Accounts\", authTableName:str=\"symetricAuthTokens\"):\n\t\t\"\"\"\n\n\n\t\tBrief:\n\n\t\t\tCreates connection to the database, creates auth-token table if non existant, and takes in the account table name.\n\t\t\n\n\t\tArguments:\n\n\t\t\t-  identifier: str\n\t\t\t\n\t\tActs as a hashed identifier, used to find a key match for a token in the database when 'SymmetricAuthTokens.checkLogin' is invoked.\n\t\t\t\n\n\t\t\t-  dbName:str = \"Accounts\"\n\t\t\t\n\t\tThe name of the '.db' (without extension) that will be used to store account and auth token data.\n\t\t\t\n\n\t\t\t-  accountTableName:str = \"Accounts\"\n\t\t\t\n\t\tThe name of the table to be created in the 'dbName.db' that will contain account info.\n\t\t\t\n\n\t\t\t-  authTableName:str = \"symetricAuthTokens\"\n\t\t\t\n\t\tThe name of the table to be created in the 'dbName.db' that will contain auth tokens.\n\t\t\\n\\n\\n\n\t\t\"\"\"\n\t\tself.con = sqlite3.connect(f'{dbName}.db')\n\t\tself.cur = self.con.cursor()\n\t\tself.identifier = identifier\n\t\tself.tableName = authTableName\n\t\tself.accountTableName = accountTableName\n\t\tself.hashGen = hashlib.sha512()\n\t\tself.authParameters = []\n\t\tSQLStatement = f'''CREATE TABLE IF NOT EXISTS {authTableName}\n\t\t\t(id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, {identifier} TEXT, tokenKey TEXT, tokenString TEXT, dateCreated DATETIME)'''\n\t\tself.cur.execute(SQLStatement)\n\t\tself.cur.execute(f\"DELETE FROM {authTableName} WHERE dateCreated < DATE('now','-1 day')\")\n\t\tself.con.commit()\n\n\tdef login(self, authID:str, accNotFoundMSG:str=\"Account not found\", **kwargs:str) -> dict:\n\t\t\"\"\"\n\t\t - kwargs should be ONLY the parameters you wish to use to login.\n\n\t\t - authID should be a non sensitive account login parameter that will act as an identifier for the auth token stored on the server.\n\n\t\t - accNotFoundMSG is the error message returned in json when an account is not found.\n\t\t\"\"\"\n\t\tkey = Fernet.generate_key().decode()\n\t\tf = Fernet(key)\n\t\ttokenStringToEncrypt = \"\"\n\t\taccTableConditions = \"\"\n\t\tpreparedValues = []\n\t\tfor key, val in kwargs.items():\n\t\t\taccTableConditions += f\" {key} = ? AND\"\n\t\t\ttokenStringToEncrypt += val\n\t\t\tpreparedValues.append(val)\n\t\tself.hashGen.update(tokenStringToEncrypt.encode('ascii'))\n\t\ttokenStringToEncrypt = self.hashGen.hexdigest()\n\t\tencryptedStr = f.encrypt(tokenStringToEncrypt.encode('ascii'))\n\t\tSQLstatement = f\"INSERT INTO {self.tableName}({self.identifier}, tokenKey, tokenString, dateCreated) VALUES (?, ?, ?, DATE('now'))\"\n\t\tself.hashGen.update(authID.encode('ascii'))\n\t\tauthID = self.hashGen.hexdigest()\n\t\tself.cur.execute(SQLstatement, (authID, key, tokenStringToEncrypt,))\n\t\tauthJson = {\n\t\t\t\"authToken\": encryptedStr.decode(),\n\t\t\t\"authID\": authID,\n\t\t\t\"error\":\"none\"\n\t\t}\n\t\t#clean up old tokens\n\t\tself.cur.execute(f\"DELETE FROM {self.tableName} WHERE dateCreated < DATE('now','-1 day')\")\n\t\tself.con.commit()\n\t\t#Check if account exists\n\t\tSQLstatement = f'''SELECT count(id) FROM {self.accountTableName} WHERE'''\n\t\tSQLstatement += accTableConditions\n\t\tSQLstatement += f\" 1 = 1\"\n\t\tself.cur.execute(SQLstatement, preparedValues)\n\t\tif self.cur.fetchone()[0] == 1:\n\t\t\treturn authJson\n\t\telse:\n\t\t\treturn {\"error\":accNotFoundMSG}\n\n\tdef checkLogin(self, authToken:str, authID:str) -> bool:\n\t\t'''\n\t\t -- Returns true on successful token, returns false on failure.\n\t\t'''\n\t\tself.cur.execute(f\"DELETE FROM {self.tableName} WHERE dateCreated < DATE('now','-1 day')\")\n\t\tself.con.commit()\n\t\tSQLstatement = f\"SELECT tokenKey, tokenString FROM {self.tableName} WHERE {self.identifier} = ?\"\n\t\tself.cur.execute(SQLstatement, (authID,))\n\t\tfor row in self.cur:\n\t\t\tf = Fernet(row[0].encode(\"ascii\"))\n\t\t\tdecryptedToken = \"\"\n\t\t\ttry:\n\t\t\t\tdecryptedToken = f.decrypt(authToken.encode(\"ascii\")).decode()\n\t\t\texcept:\n\t\t\t\treturn False\n\t\t\treturn decryptedToken == row[1]\n\t\treturn False\n\n\tdef logout(self, authToken:str, authID:str) -> bool:\n\t\t\"\"\"\n\t\t -- Used to logout accounts/delete tokens from the database.\n\t\t\"\"\"\n\t\tself.cur.execute(f\"DELETE FROM {self.tableName} WHERE dateCreated < DATE('now','-1 day')\")\n\t\tself.con.commit()\n\t\ttry:\n\t\t\tSQLstatement = f\"DELETE FROM {self.tableName} WHERE {self.identifier} = ?\"\n\t\t\tself.cur.execute(SQLstatement, (authID,))\n\t\t\treturn True\n\t\texcept:\n\t\t\treturn False\n\n\tdef configAccountSystem(self, authParameters:tuple | list):\n\t\t'''\n\t\t -- must be used in place of initAccountSystem() after it has been called once.\n\t\t'''\n\t\tself.authParameters = authParameters\n\n\tdef initAccountSystem(self, requiredParameters:tuple | list = [], authParameters:tuple | list = [], **kwargs:str) -> bool:\n\t\t'''\n\t\t -- Should only be called once.  Afterwords replace with configAccountSystem()\n\n\t\t - requiredParameters should contain keys from kwargs/account parameters which you wish to make required.\n\n\t\t - kwargs should contain key value pairs of account parameters/data you wish to associate with an account.\n\t\t'''\n\t\tself.authParameters = authParameters\n\t\tSQLStatement = f'''CREATE TABLE IF NOT EXISTS {self.accountTableName}\n\t\t\t(id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, '''\n\t\tprint(f\"\\n----\\nEARWIGAUTH - [SQLITE] Creating AUTH table:\\n\\t\\\"{self.accountTableName}\\\" PARAMETERS ( - Parameter: SQL Data type)\\n\")\n\t\tfor key, value in kwargs.items():\n\t\t\tprint(f\" - {key}: {value}\\n\")\n\t\t\tif key in requiredParameters:\n\t\t\t\tSQLStatement += f\"{key} {value}, \"\n\t\t\telse:\n\t\t\t\tSQLStatement += f\"{key} {value} DEFAULT \\\"Not provided\\\", \"\n\t\tSQLStatement += \"dateCreated DATETIME)\"\n\t\ttry:\n\t\t\tself.cur.execute(SQLStatement)\n\t\t\tself.con.commit()\n\t\t\treturn True\n\t\texcept:\n\t\t\treturn False\n\n\tdef addAccount(self, **kwargs:str) -> bool:\n\t\t'''\n\t\t - authParameters should contain any sensitive account parameters such as passwords that should be hashed in the database.\n\n\t\t - kwargs should include any (including login) parameters associated with the account system created using initAccountSystem().\n\t\t'''\n\t\tSQLStatement = f'''CREATE TABLE IF NOT EXISTS {self.accountTableName}\n\t\t\t(id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, '''\n\t\tparametersToInsert = \"\"\n\t\tvaluesToInsert = []\n\t\tpreparations = \"\"\n\t\tfor key, val in kwargs.items():\n\t\t\tSQLStatement += f\"{key} text, \"\n\t\t\tparametersToInsert += f\"{key}, \"\n\t\t\tpreparations += \"?, \"\n\t\t\tif val in self.authParameters:\n\t\t\t\tself.hashGen.update(val)\n\t\t\t\tvaluesToInsert.append(self.hashGen.hexdigest())\n\t\t\telse:\n\t\t\t\tvaluesToInsert.append(val)\n\t\tSQLStatement += \"dateCreated DATETIME)\"\n\t\ttry:\n\t\t\tself.cur.execute(SQLStatement)\n\t\texcept:\n\t\t\treturn False\n\t\tSQLStatement = f'''INSERT INTO {self.accountTableName}('''\n\t\tSQLStatement += parametersToInsert\n\t\tSQLStatement += ''' dateCreated) VALUES ('''\n\t\tSQLStatement += preparations\n\t\tSQLStatement += '''DATE('now'))'''\n\t\ttry:\n\t\t\tself.cur.execute(SQLStatement, valuesToInsert)\n\t\t\tself.con.commit()\n\t\t\treturn True\n\t\texcept:\n\t\t\treturn False\n\n\tdef removeAccount(self, **kwargs:str) -> bool:\n\t\t\"\"\"\n\t\t - authParameters should contain a tuple/list of any parameters that were hashed/sensitive when addAccount() was invoked.  In other words, if one of your parameters in kwargs was included in addAccount()'s authParameters parameter, you must include its value in this method's authParameters parameter.\n\n\t\t - kwargs should be the parameters used to find the account in the account database which you wish to remove.\n\t\t\"\"\"\n\t\tSQLStatement = f\"DELETE FROM {self.accountTableName} WHERE \"\n\t\tpreparedParameters = []\n\t\tfor key, val in kwargs.items():\n\t\t\tSQLStatement += f\"{key} = ? AND \"\n\t\t\tif val in self.authParameters:\n\t\t\t\tself.hashGen.update(val)\n\t\t\t\tpreparedParameters.append(self.hashGen.hexdigest())\n\t\t\telse:\n\t\t\t\tpreparedParameters.append(val)\n\t\tSQLStatement += \"1 = 1\"\n\t\ttry:\n\t\t\tself.cur.execute(SQLStatement, preparedParameters)\n\t\t\tself.con.commit()\n\t\t\treturn True\n\t\texcept:\n\t\t\treturn False\n\tdef close(self):\n\t\tself.con.close()\n\tdef __enter__(self):\n\t\treturn self\n\tdef __exit__(self, exc_type, exc_value, exc_traceback):\n\t\tself.con.close()\n\n\n\"\"\" EXAMPLE CODE:\nwith SymmetricAuthTokens(\"username\", dbName='test') as accountManager:\n\taccountManager.initAccountSystem(username = \"varchar(30)\", password = \"varchar(30)\")\n\taccountManager.addAccount(username = \"Bert\", password = \"123abc\")\n\tprint(json.dumps(accountManager.loginUser(\"Bert\", username = \"Bert\", password = \"123abc\")))#returns token and identifier as dict\n\tprint(accountManager.checkLogin(\"Bert's identifier hash\", \"Bert's token hash\"))#validates login and returns true or false\n\"\"\"", "projects\\Earwig Web Framework\\root\\libs\\projectModules\\htmlconstructor.py": "#earwig HTML Constructor\n\n\nclass eh(object):\n\tdef __init__(self, element:str, attributes:dict, scope:list, ind:int=0, singleAttributes:list|tuple = []):\n\t\tself.element = element\n\t\tself.attributes = attributes\n\t\tself.scope = scope\n\t\tself.index = ind\n\t\tself.singleAttributes = singleAttributes\n\tdef __str__(self) -> str:\n\t\tretStr = f\"<{self.element}\"\n\t\tfor attr, val in self.attributes.items():\n\t\t\tretStr = f\"{retStr} {attr}=\\\"{val}\\\"\"\n\t\tfor attr in self.singleAttributes:\n\t\t\tretStr = f\"{retStr} {attr}\"\n\t\tretStr = f\"{retStr}>\"\n\t\tfor elem in self.scope:\n\t\t\tretStr = f\"{retStr}{elem}\"\n\t\tretStr = f\"{retStr}</{self.element}>\"\n\t\treturn retStr\n\tdef __format__(self, __format_spec: str) -> str:\n\t\tretStr = f\"<{self.element}\"\n\t\tfor attr, val in self.attributes.items():\n\t\t\tretStr = f\"{retStr} {attr}=\\\"{val}\\\"\"\n\t\tfor attr in self.singleAttributes:\n\t\t\tretStr = f\"{retStr} {attr}\"\n\t\tretStr = f\"{retStr}>\"\n\t\tfor elem in self.scope:\n\t\t\tretStr = f\"{retStr}{elem}\"\n\t\tretStr = f\"{retStr}</{self.element}>\"\n\t\treturn retStr\n\tdef sort_ascending_index(self):\n\t\tnewScope = dict(zip([elem.index for elem in self.scope], self.scope))\n\t\ttry:\n\t\t\tself.scope = [newScope[i] for i in range(len(newScope))]\n\t\texcept:\n\t\t\tself.scope = []\n\t\t\tnewIndexes = list(newScope.keys())\n\t\t\tnewIndexes.sort()\n\t\t\tfor i in newIndexes:\n\t\t\t\t\tself.scope.append(newScope[i])\n\t\treturn self\n\tdef sort_descending_index(self):\n\t\tnewScope = dict(zip([elem.index for elem in self.scope], self.scope))\n\t\ttry:\n\t\t\tself.scope = [newScope[i] for i in range(len(newScope))]\n\t\t\tself.scope.reverse()\n\t\texcept:\n\t\t\tself.scope = []\n\t\t\tnewIndexes = list(newScope.keys())\n\t\t\tnewIndexes.sort()\n\t\t\tfor i in newIndexes:\n\t\t\t\tself.scope.append(newScope[i])\n\t\t\tself.scope.reverse()\n\t\treturn self\n\tdef push(self, elements:list|tuple):\n\t\tself.scope += elements\n\t\treturn self\n\tdef __add__(self, other):\n\t\t\treturn f\"{self}{other}\"\n\tdef __radd__(self, other):\n\t\t\treturn f\"{other}{self}\"\n\n'''EXAMPLE CODE\nprint(\n\teh(\"header\", {}, [\n\t\teh(\"title\", {}, [\n\t\t\t\"This is a test site.\"\n\t\t])\n\t])+\n\teh(\"body\", {}, [\n\t\teh(\"p\",{},[\n\t\t\tf\"{z}\"\n\t\t], ind=z) for z in range(1, 6)\n\t]\n\t).push([\n\t\teh(\"script\",{},[\n\t\t\t\"\"\"alert(\"Hello lol.\")\"\"\"\n\t\t],singleAttributes=[\"defer\"])\n\t])\n\t)\n'''"}}, "projects\\Earwig Web Framework\\root\\README.md": "# Earwig 0.11.2\n**NOTE: This software is in a beta version, we cannot at this time ensure its stability.**\n\n Earwig is an http server that enables you serve _.py_ and _.ear_ source files alot like how _.php_ source files are served.\n\n## How To Get Started (Basic)\n\n Earwig is easy to setup and get working with only a few steps:\n1. Go into your __settings.txt__ file and change the default port to your desired port.\n2. Make a new file with a __.py__ extension.\n3. Now add that file as a route by adding a line to your __settings.txt__ following the format: _UrlRoute=filepathWithExtension_\n4. Now run your server by entering the following into a terminal:\n```cli\npy earwig.py\n```\nIf all was done correctly, you should be able to find your server hosted at [http://localhost:8000/](http://localhost:8000/) (Assuming you used port 8000)\n\n## How Earwig Works (Abridged)\n\nEarwig redirects the python stdout to the http response for incoming http requests.  In other words, anything that is __print()__ed in your earwig page files will be rendered/be the response for the requested url.\n\n## Configuring Your Server Settings and Globals\n\nEarwig server settings are configured in your _settings.EWS_ file.  A bare bones settings.EWS file might look like this:\n\n```lua\n/!/ Server Settings:\n\nport=8000\nip=localhost\ndevmode=false\n\n/!/ Json User Defined Settings:\n\nhashedAuthParameters~[\"password\", \"securityQuestion\"]\nexampleDict~{\"setting\":\"abc\"}\nstartupMessage~\"SERVER STARTED\"\nexampleNumber~-9.99\nexampleBool~false\n\n/!/ Init File:\n\n@_boot_.py\n\n/!/ Forbidden File Extensions:\n\n!ear\n!py\n!db\n!EWS\n\n/!/ Startup Routes:\n\n~=root.py\n```\n\n---\n\n__NOTE__: The order in which you add settings to your _settings.EWS_ file does not matter.\n\n### IP AND PORT\n\nyour server IP and Port can be defined by adding the following to your settings file:\n\n```lua\nport=8000\nip=localhost\n```\n\nlocalhost is the ip for a localy hosted server.\n\n### DEVMODE\n\n```lua\ndevmode=false\n```\n\n__IMPORTANT__: It is important that when you are deploying your server that _devmode_ is set to _false_.  _devmode_ can cause slowdowns (and potentialy security issues in future versions of earwig) if enabled in your deployed server.\n\n_devmode_ allows for better python error checking when dealing with _.py_ and _.ear_ pages along with other debug features that arent fully implemented yet.  Dev mode also ensures a full recompile of your _.py_ and _.ear_ pages with every request.\n\n### COMMENTS\n\n`/!/` is the prefix for commented lines\n\n### USER DEFINED SETTINGS/GLOBALS\n\n```lua\nsettingName~[\"SomeJson\":{\"AlsoJson\":0,\"StillJson\"}, \"NotNotJson\":-123.456]\nAnotherSetting~\"A string.\"\nAThirdSetting~-3333.3333\nAFourthSetting~123\nAFithSetting~false\n```\n\n_~_ is used as the operator to assign custom settings.  Custom settings can be assigned to any valid json, float, string, integer, or boolean.\n\n### BOOT FILE PATH\n\nThe boot file is a _.py_ script that is executed at the startup of your server.  To define the path to a boot file, use the _@_ prefix before your boot file path in your settings file.\n\nExample:\n\n```lua\n@src/startup/boot.py\n```\n\n### FORBIDDEN EXTENSIONS\n\nForbidden extensions are defined with the prefix _!_.\n\nExample:\n\n```lua\n!db\n!py\n!ear\n```\n\nDeclaring extensions as forbidden will make it impossible for http clients to recieve the raw data from requested files with that extension.\n\n### ROUTING\n\nRouting is how you declare the url routes and their corresponding _.ear_ or _.py_ page file.  Its as easy as `urlroute/urlroute=filepath/file.py` or `urlroute/urlroute=filepath/file.ear`.\n\nExample:\n\n```lua\n~=pages/root.py\nabout=pages/about.py\ncontact=pages/contact.ear\n```\n\n_~_ is used to declare the URL's root route.\n\n`~=pages/root.py` means that `pages/root.py` will handle requests sent to `http://yourdns.com/`\n\n`about=pages/about.py` means that `pages/about.py` will handle requests sent to `http://yourdns.com/about`\n\n`contact=pages/contact.ear` means that `pages/contact.py` will handle requests sent to `http://yourdns.com/contact`\n\n## Framework Globals and Accessables\n\nThese globals can be accessed in any _.py_ or _.ear_ page file as declared in the routes of your _settings.EWS_ file.\n\n---\n\n`R_get[\"requestAttribute\"]`\n\nR_get is a dictionary containing all parameters/attributes of the incoming GET request.\n\n---\n\n`R_post[\"requestAttribute\"]`\n\nR_post is a dictionary containing all parameters/attributes of the incoming POST request.\n\n---\n\n`_BASE_URL`\n\nProvides the Root of the http URL.  Example _http://yourdns.com/_\n\n---\n\n`_FULL_URL`\n\nProvides the full http URL with route.  Example _http://yourdns.com/pages/about_\n\n---\n\n`_PATH_URL`\n\nProvides the path after the base of the page URL. Example _/pages/about_\n\n---\n\n`_ORIGIN`\n\nProvides the address of the origin of the request (ie: the request client's ip).  Can be used to create blacklists dynamically.\n\n---\n\n`_COOKIES`\n\nProvides a dictionary of all of the cookies from the incoming request.\n\n---\n\n`_MIME_TYPE`\n\nThe current mime type for the requested page.\n\n## Framework Functions\n\nThese functions can be executed in any _.py_ or _.ear_ page file as declared in the routes of your _settings.EWS_ file.\n\n---\n\n`mime_type(mime:str):`\n\nChange the response mime type.  Returns the mime type.\n\n---\n\n`set_headers(headerDict:dict = {})`\n\nSet/add the headers for the response.  Returns the dictionary of all the headers.\n\n---\n\n`set_setting(_setting:str, _newvalue)`\n\nChange/set a setting. returns the setting's new value.\n\n---\n\n`delete_setting(_setting:str) -> bool`\n\nDeletes a setting. Returns true on success, False on failure.\n\n---\n\n`set_route(_route:str, _path:str)`\n\nSets a new or existing route dynamically.  Returns a tuple of ( **_route**, **_path** ).\n\n---\n\n`delete_route(_routeOrPath:str, _isRoute: bool = True) -> bool`\n\nDeletes an existing route.  Returns true on success, fail on failure.\n\n---\n\n`append_setting(_setting:str, _appendvalue)`\n\nAppends the *_appendvalue* to the value of the setting provided.  On failure returns false. On success returns the setting's new value.\n\n---\n\n`pop_setting(_setting, num:int = False)`\n\nPerforms a _.pop()_ on the value of the setting provided.\n\n## Earwig HTML Renderer\n\n```python3\nprint(\n eh(\"header\", {}, [\n   eh(\"title\", {}, [\n    \"This is a test site.\"\n   ])\n  ])+\n  eh(\"body\", {}, [\n   eh(\"p\",{},[\n    f\"{z}\"\n   ], ind=z) for z in range(1, 6)\n  ]\n  ).push([\n   eh(\"script\",{},[\n    \"\"\"alert(\"Hello.\")\"\"\"\n   ],singleAttributes=[\"defer\"])\n  ])\n)\n```\n\nThe Earwig HTML Renderer allows you to easier tokenize certain elements and apply indexes to them with the _ind_ attribute.  This allows for easier server side procedural element generation, element sorting, and other useful features that are implemented into the _eh_ class. The above code will render the following HTML:\n\n```html\n<header>\n <title>This is a test site.</title>\n</header>\n<body>\n <p>1</p>\n <p>2</p>\n <p>3</p>\n <p>4</p>\n <p>5</p>\n <script defer>\n  alert(\"Hello.\")\n </script>\n</body>\n```\n\n## Auth Tokens\n\n_WARNING: The current standard library auth tokens utilizes SQLite.  Only use this if you wish to use SQLite as your database._\n\n### SYMETRIC AUTH TOKENS\n\nEarwig provides an easy system to set up login tokens and credentials with just a class and a few functions.  With this system you can decide which login parameters are sensitive/hashed.  Auth tokens are both hashed then excrypted.\n\n---\n\n**_CONSTRUCTOR_**\n\n`SymmetricAuthTokens(identifier:str, dbName:str=\"Accounts\", accountTableName:str=\"Accounts\", authTableName:str=\"symetricAuthTokens\")`\n\nThe _SymmetricAuthTokens_ class is used as the main handler for your auth system.  You can initialize the class either in a _with_ statement, or call _.close()_ when no longer in use.  This will initialize the auth token table if not already existing.  Each of its constructor's parameters provide a level of control over your auth system:\n\n - __identifier__ : This is the column name/account parameter in the database that will act as the association between each account and tokens made by those accounts.  The best practice is to make this an account parameter that is not sensitive.\n \n - __dbName__ : This is the name of the _.db_ file that your auth system will connect to.\n \n - __accountTableName__ : This is the name of the table in your auth database that will hold all user accounts.\n \n - __authTableName__ : This is the name of the table in your auth database that will hold all created auth tokens.\n\n---\n\n**_INITIALIZING THE ACCOUNT SYSTEM_**\n\n`.initAccountSystem(requiredParameters:tuple | list = [], authParameters:tuple | list = [], **kwargs:str) -> bool`\n\nThe _.initAccountSystem_ member function is used to initialize the account system.  To maximize performance, this should only be called in a _boot.py_ file.  This function will return true on success and false on failure.  The parameters you provide will determine how your account system will function:\n\n - __requiredParameters__ : The account parameters/database columns that you want to make required in order to successfully make an account.  On success, this will return _true_ and on failure this will return _false_.\n - __authParameters__ : All account parameters/database columns that you would like users to use to login to their account/recive an auth token.\n - __kwargs__ : All and every account parameter that you wish to store in the database/account table should be named as a key and their SQL type should be its value as a string.\n\n## The Earwig Preprocessor (.ear) (Expiremental)\n\n__Documentation for the Earwig preprocessor can be found here: https://github.com/FrewtyPebbles/Earwig-Template-Engine/wiki__\n", "projects\\Earwig Web Framework\\root\\settings.EWS": "/!/ Server Settings:\nport=8000\nip=localhost\ndevmode=false\n/!/ Json User Defined Settings:\nhashedAuthParameters~[\"password\", \"securityQuestion\"]\nexampleDict~{\"setting\":\"abc\"}\nstartupMessage~\"SERVER STARTED\"\nexampleNumber~-9.99\nexampleBool~false\n/!/ Init File:\n@_boot_.py\n/!/ Forbidden File Extensions:\n!ear\n!py\n!db\n!EWS\n/!/ Startup Routes:\n~=root.py"}}}