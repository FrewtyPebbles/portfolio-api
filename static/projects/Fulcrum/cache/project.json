{"root": {"projects\\Fulcrum\\root": {"projects\\Fulcrum\\root\\.gitignore": "/target\n/tests", "projects\\Fulcrum\\root\\Cargo.lock": "# This file is automatically @generated by Cargo.\n# It is not intended for manual editing.\nversion = 3\n\n[[package]]\nname = \"autocfg\"\nversion = \"1.1.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d468802bab17cbc0cc575e9b053f41e72aa36bfa6b7f55e3529ffa43161b97fa\"\n\n[[package]]\nname = \"fulcrum\"\nversion = \"0.8.9\"\ndependencies = [\n \"indexmap\",\n]\n\n[[package]]\nname = \"hashbrown\"\nversion = \"0.12.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"8a9ee70c43aaf417c914396645a0fa852624801b24ebb7ae78fe8272889ac888\"\n\n[[package]]\nname = \"indexmap\"\nversion = \"1.9.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1885e79c1fc4b10f0e172c475f458b7f7b93061064d98c3293e98c5ba0c8b399\"\ndependencies = [\n \"autocfg\",\n \"hashbrown\",\n]\n", "projects\\Fulcrum\\root\\Cargo.toml": "[package]\nname = \"fulcrum\"\nversion = \"0.8.9\"\nedition = \"2021\"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[dependencies]\nindexmap = \"1.9.2\"", "projects\\Fulcrum\\root\\LICENSE": "MIT License\n\nCopyright (c) 2022 William Lim\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n", "projects\\Fulcrum\\root\\README.md": "# Fulcrum 0.8.9\nA fast and straight forward scripting language with a tiny binary and a functional programming paradigm. \n\n## Documentation\n\n## Features:\n\n - Higher order functions.\n\n - An extremely minimal and basic syntax.\n\n - An compact interpreter that can be packaged with your project.\n\n## Language Rules:\n\n - Assignments, function calls, and return statements must be ended with a `;`\n\n - Operators are not yet a part of the language but operations can be done via functions.\n\n - Functions defined inside of other functions only are callable inside of the parent function and inherit all of the parent function's variables and function definitions.\n\n - Higher order functions must include a function name, this requirement will be taken out once a new syntax for function literals is added.\n\n - When exiting any scope, all variables defined within that scope are deleted.\n\n - Nothing is passed by reference, all variables are modified via the `=` asignment operator.\n\n## Language Keywords and syntax:\n\n - `fun` : Prefixes a function definition.\n\n - `return` : Returns a value from a user defined function.\n\n - `break` : Breaks out of a scope.\n\n - `if` : Prefixes the condition for an if block.\n\n - `elif` : Prefixes the condition for an elif block.\n\n - `else` : Prefixes an else block.\n\n - `loop` : Prefixes a loop block. Loop blocks will loop indefinitely until they hit a break or return.\n\n - `while` : Prefixes a while block. while blocks will loop as long as their statement is true.\n\n - `[]` : Wraps a list literal or is used to hold the offset for an index/offset operator.\n\n - `=` : Used to declare or assign to existing variables.\n\n - `'` : Wraps a string literal.\n\n - `in` : Operator that checks if the left side is in the right side when not used inside a for loop.\n\n\n - `;` : Denotes the end of a line.\n\n - `()` : Suffixes a function name when calling or declaring that function. Wraps function arguments when calling a function and wraps function argument names when declaring a function.\n\n - `true`|`yes`|`t` : Aliases for the boolean literal `true`.\n\n - `false`|`no`|`f` : Aliases for the boolean literal `false`.\n\n## Non-traditional Functionalities\n\n - Loops\n\n```\nloop {\n\tprint('Loop!\\n');\n}\n```\n\nLoops will loop until the path of execution hits a `break` or a `return`.\n\n - For loops\n\n```\n// String Example\n\nfor i in 'abc' {\n\tprint(add(i, '\\n'));\n}\n\n// output:\n// a\n// b\n// c\n\n// Integer Example\n\nfor i in 3 {\n\tprint(add(i, '\\n'));\n}\n\n// output:\n// 0\n// 1\n// 2\n\n// List Example\n\nfor i in ['1', 2.0, 3] {\n\tprint(add(i, '\\n'));\n}\n\n// output:\n// 1\n// 2.0\n// 3\n\n// Variable Example\n\nvariable = [0, 1, 2];\nfor i in variable {\n\tprint(add(i, '\\n'));\n}\n\n// output:\n// 0\n// 1\n// 2\n```\n\n## Standard Library Functions:\n\nFunctions in fulcrum return the result of their operation.\n\n - `print(val)` : Prints a value to the standard output.\n\n - `input()` : Gets user input.\n\n - `read(filepath)` : Returns the contents of the file provided.\n\n - `write(filepath, new_content, writemode)` : Writes the `new_content` to the file provided based on the writemode which can be `'a'` for append or `'t'` for truncate.\n\n - `add(val1, val2)` : Adds 2 values. also concatenates strings.\n\n - `sub(val1, val2)` : Subtracts 2 values. also removes substrings from strings.\n\n - `mul(val1, val2)` : Multiplies 2 values.\n\n - `div(val1, val2)` : divides 2 values.\n\n - `E(val1, val2)` : Tests if two values are equal and returns boolean.\n\n - `NE(val1, val2)` : Tests if two values are not equal and returns boolean.\n\n - `G(val1, val2)` : Tests if `val1` is greater than `val2`.\n\n - `L(val1, val2)` : Tests if `val1` is less than `val2`.\n\n - `GE(val1, val2)` : Tests if `val1` is greater than or equal to `val2`.\n\n - `LE(val1, val2)` : Tests if `val1` is less than or equal to `val2`.\n\n - `and(condition1, condition2)` : Tests if both conditions are true and returns boolean.\n\n - `or(condition1, condition2)` : Tests if one of the conditions are true and returns boolean.\n\n - `INT(val)` : Casts the type to an Int.\n\n - `FLOAT(val)` : Casts the type to a Float.\n\n - `BOOL(val)` : Casts the type to a Boolean.\n\n - `STRING(val)` : Casts the type to a String.\n\n - `cat(val1, val2, val3, ...)` : Concatenates multiple values into a string.\n\n - `split(string, substring)` : Splits a string by a substring.\n\n - `trim(string)` : Removes the leading and trailing whitespace from a string.\n\n - `replace(string, substring1, substring2)` : Replaces the substring1 in the string with substring2.\n\n - `pop(list)` : pops a value from a list.\n \n - `push(list, value)` : pops a value from a list.\n\n - `len(string`|`list)` : Returns the len of the first argument.\n\n - `range(num1, num2)` : Returns a list of integers from num1 to num2.\n\n - `rev(list`|`string)` : Reverses a list or string.\n\n - `CLI(integer)` : Returns command line arguments.\n\n - `import(module_path)` : imports all definitions/functions from the `.ful` file at the path specified into the current scope.\n\n## Example Program:\n\nTic Tac Toe:\n```\n# tictactoe.ful\nfun tictactoe() {\n\t# Board will act as a global that will hold the state of the tic tac toe board.\n\tboard = [\n\t\t# 1   2   3\n\t\t[' ',' ',' '], #a\n\t\t[' ',' ',' '], #b\n\t\t[' ',' ',' ']  #c\n\t];\n\n\tfun check_winner() {\n\t\t#horizontal\n\t\tif E(board[0], ['O', 'O', 'O']) {\n\t\t\treturn 'O';\n\t\t}\n\t\telif E(board[0], ['X', 'X', 'X']) {\n\t\t\treturn 'X';\n\t\t}\n\t\telif E(board[1], ['O', 'O', 'O']) {\n\t\t\treturn 'O';\n\t\t}\n\t\telif E(board[1], ['X', 'X', 'X']) {\n\t\t\treturn 'X';\n\t\t}\n\t\telif E(board[2], ['O', 'O', 'O']) {\n\t\t\treturn 'O';\n\t\t}\n\t\telif E(board[2], ['X', 'X', 'X']) {\n\t\t\treturn 'X';\n\t\t}\n\t\t#vertical\n\t\telif and(and(E(board[0][0], 'O'), E(board[1][0], 'O')), E(board[2][0], 'O')) {\n\t\t\treturn 'O';\n\t\t}\n\t\telif and(and(E(board[0][0], 'X'), E(board[1][0], 'X')), E(board[2][0], 'X')) {\n\t\t\treturn 'X';\n\t\t}\n\t\telif and(and(E(board[0][1], 'O'), E(board[1][1], 'O')), E(board[2][1], 'O')) {\n\t\t\treturn 'O';\n\t\t}\n\t\telif and(and(E(board[0][1], 'X'), E(board[1][1], 'X')), E(board[2][1], 'X')) {\n\t\t\treturn 'X';\n\t\t}\n\t\telif and(and(E(board[0][2], 'O'), E(board[1][2], 'O')), E(board[2][2], 'O')) {\n\t\t\treturn 'O';\n\t\t}\n\t\telif and(and(E(board[0][2], 'X'), E(board[1][2], 'X')), E(board[2][2], 'X')) {\n\t\t\treturn 'X';\n\t\t}\n\t\t#diagonal\n\t\telif and(and(E(board[0][0], 'O'), E(board[1][1], 'O')), E(board[2][2], 'O')) {\n\t\t\treturn 'O';\n\t\t}\n\t\telif and(and(E(board[0][0], 'X'), E(board[1][1], 'X')), E(board[2][2], 'X')) {\n\t\t\treturn 'X';\n\t\t}\n\t\telif and(and(E(board[2][0], 'O'), E(board[1][1], 'O')), E(board[0][2], 'O')) {\n\t\t\treturn 'O';\n\t\t}\n\t\telif and(and(E(board[2][0], 'X'), E(board[1][1], 'X')), E(board[0][2], 'X')) {\n\t\t\treturn 'X';\n\t\t}\n\n\t\treturn '';\n\t}\n\n\tfun update_board(current_player) {\n\t\t# This function starts a turn for a player.\n\n\t\tfun print_board() {\n\t\t\t# this function renders the current board.\n\t\t\t# board is inherited from top most function and acts as a global.\n\t\t\tprint(add(add(add(add(board[0][0], '|'),board[0][1]),'|'),board[0][2]));\n\t\t\tprint('\\n-----\\n');\n\t\t\tprint(add(add(add(add(board[1][0], '|'),board[1][1]),'|'),board[1][2]));\n\t\t\tprint('\\n-----\\n');\n\t\t\tprint(add(add(add(add(board[2][0], '|'),board[2][1]),'|'),board[2][2]));\n\t\t\tprint('\\n');\n\t\t}\n\n\t\t# render the board at the start of the turn\n\t\tprint_board();\n\n\t\t# check for a winner\n\t\tis_winner = check_winner();\n\t\tif is_winner {\n\t\t\twrite('tictactoe_wins.txt', add(is_winner, ', '), 'a');\n\t\t\tprint(add(add('The winner is: ', is_winner), '\\n'));\n\t\t\tprint('Previous wins:\\n');\n\t\t\tprint(read('tictactoe_wins.txt'));\n\t\t\treturn is_winner;\n\t\t}\n\n\t\t# Get horizontal input.\n\t\tprint('horizontal:');\n\t\tx = sub(INT(input()),1);\n\t\t\n\t\t# Get vertical input.\n\t\tprint('vertical:');\n\t\ty = sub(INT(input()), 1);\n\t\t\n\t\t# Set the current player at that position.\n\t\tboard[x][y] = current_player;\n\t\t\n\t\t# Check who the current player is to recursively call update board as the other player.\n\t\tif E(current_player, 'X') {\n\t\t\treturn update_board('O');\n\t\t}\n\t\telse {\n\t\t\treturn update_board('X');\n\t\t}\n\t}\n\treturn update_board('X');\n}\n\n# Run the game\ntictactoe();\n```\n", "projects\\Fulcrum\\root\\src": {"projects\\Fulcrum\\root\\src\\main.rs": "mod parts;\nuse std::env;\nuse std::fs;\n\nuse parts::tokenizer::tokenize;\nconst VERSION:&str = \"0.8.9\";\nfn main() {\n    let args:Vec<String> = env::args().collect();\n\tif args.len() == 0 {\n\t\t//No args\n\t\tprintln!(\"__Fulcrum_interpreter_v{VERSION}__\\n USAGE: fulcrum <filepath.ful>\");\n\t}\n\telse if args[1].starts_with(\"-\"){\n\t\tmatch args[1].to_lowercase().as_str() {\n\t\t\t\"-c\" => {\n\t\t\t\ttokenize(args[2].replace(\"\\\"\", \"\\\\\\\"\").clone(), args[0].clone(), args);\n\t\t\t}\n\t\t\t\"-v\" => {\n\t\t\t\tprint!(\"{VERSION}\");\n\t\t\t}\n\t\t\t_ => {\n\t\t\t\tprintln!(\"INVALID FLAG\");\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tlet contents = fs::read_to_string(args[1].clone())\n\t\t\t.expect(\"Invalid filepath\");\n\t\ttokenize(contents.clone(), args[1].clone(), args);\n\t}\n}\n", "projects\\Fulcrum\\root\\src\\parts": {"projects\\Fulcrum\\root\\src\\parts\\datastructures.rs": "#[derive(PartialEq, Debug, Clone)]\npub enum Token {\n\tFuncCall(Box<String>),\n\tFuncDeff(Box<String>),\n\tIf,\n\tElIf,\n\tEl,\n\tStatementEnd,\n\tStringLit(Box<String>),\n\tIntLit(Box<i128>),\n\tFloatLit(Box<f64>),\n\tBooleanLit(Box<bool>),\n\tStartScope,\n\tEndScope,\n\tStartVec,\n\tEndVec,\n\tVariable(Box<String>),\n\tIndexStart,\n\tIndexEnd,\n\tAssign,\n\tReturn,\n\tEndLine,\n\tDelimeter,\n\tFor,\n\tIn,\n\tWhile,\n\tLoop,\n\tBreak,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub enum NodeType {\n\tCall,\n\tDef,\n\tAssign,\n\tVariable,\n\tReturn,\n\tCondition,\n\tStr(Box<String>),\n\tInt(Box<i128>),\n\tFloat(Box<f64>),\n\tBool(Box<bool>),\n\t//vector holds variables in the arguments\n\tVector,//(Box<Vec<Box<NodeType>>>),\n\t//argument 1 is the value argument 2 is the index\n\tIndex,\n\tLoop,\n\tOperator,\n\tBreak,\n\tNone\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub struct StackNode {\n\tpub operation: Box<String>,\n\tpub ntype:Box<NodeType>,\n\tpub args:Box<Vec<Box<StackNode>>>,\n\tpub scope:Box<Vec<Box<StackNode>>>\n}\n\nimpl Default for StackNode {\n    fn default() -> Self {\n        Self { operation: Default::default(), ntype: Box::new(NodeType::Call), args: Default::default(), scope: Default::default() }\n    }\n}", "projects\\Fulcrum\\root\\src\\parts\\parser": {"projects\\Fulcrum\\root\\src\\parts\\parser\\standard.rs": "use std::{fs::{self, OpenOptions, File}, path::PathBuf};\n\nuse crate::parts::{datastructures::{NodeType, StackNode}, parser::Parser, tokenizer::tokenize};\n\nimpl Parser {\n\tpub fn add(&mut self, lhs:Box<NodeType>, rhs:Box<NodeType>) -> Box<NodeType> {\n\t\tmatch *lhs {\n\t\t\tNodeType::Str(val) => match *rhs {\n\t\t\t\tNodeType::Str(val2) => Box::new(NodeType::Str(Box::new(format!(\"{val}{val2}\")))),\n\t\t\t\tNodeType::Int(val2) => Box::new(NodeType::Str(Box::new(format!(\"{val}{val2}\")))),\n\t\t\t\tNodeType::Float(val2) => Box::new(NodeType::Str(Box::new(format!(\"{val}{val2}\")))),\n\t\t\t\tNodeType::Bool(val2) => Box::new(NodeType::Str(Box::new(format!(\"{val}{val2}\")))),\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t},\n\t\t\tNodeType::Int(val) => match *rhs {\n\t\t\t\tNodeType::Str(val2) => Box::new(NodeType::Str(Box::new(format!(\"{val}{val2}\")))),\n\t\t\t\tNodeType::Int(val2) => Box::new(NodeType::Int(Box::new(*val + *val2))),\n\t\t\t\tNodeType::Float(val2) => Box::new(NodeType::Int(Box::new(*val + *val2 as i128))),\n\t\t\t\tNodeType::Bool(val2) => Box::new(NodeType::Int(Box::new(*val + *val2 as i128))),\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t},\n\t\t\tNodeType::Float(val) => match *rhs {\n\t\t\t\tNodeType::Str(val2) => Box::new(NodeType::Str(Box::new(format!(\"{val}{val2}\")))),\n\t\t\t\tNodeType::Int(val2) => Box::new(NodeType::Float(Box::new(*val + *val2 as f64))),\n\t\t\t\tNodeType::Float(val2) => Box::new(NodeType::Float(Box::new(*val + *val2 as f64))),\n\t\t\t\tNodeType::Bool(val2) => Box::new(NodeType::Float(Box::new(*val + if *val2 {1.0} else {0.0}))),\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t},\n\t\t\tNodeType::Bool(val) => match *rhs {\n\t\t\t\tNodeType::Str(val2) => Box::new(NodeType::Str(Box::new(format!(\"{val}{val2}\")))),\n\t\t\t\tNodeType::Int(val2) => Box::new(NodeType::Bool(Box::new(*val && if *val2 >= 1 {true} else {false}))),\n\t\t\t\tNodeType::Float(val2) => Box::new(NodeType::Bool(Box::new(*val && if *val2 >= 1.0 {true} else {false}))),\n\t\t\t\tNodeType::Bool(val2) => Box::new(NodeType::Bool(Box::new(*val && *val2))),\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t},\n\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t}\n\t}\n\n\tpub fn and(&mut self, lhs:Box<NodeType>, rhs:Box<NodeType>) -> Box<NodeType> {\n\t\tmatch *lhs {\n\t\t\tNodeType::Str(val) => match *rhs {\n\t\t\t\tNodeType::Str(val2) => Box::new(NodeType::Str(Box::new(format!(\"{val}{val2}\")))),\n\t\t\t\tNodeType::Int(val2) => Box::new(NodeType::Str(Box::new(format!(\"{val}{val2}\")))),\n\t\t\t\tNodeType::Float(val2) => Box::new(NodeType::Str(Box::new(format!(\"{val}{val2}\")))),\n\t\t\t\tNodeType::Bool(val2) => Box::new(NodeType::Str(Box::new(format!(\"{val}{val2}\")))),\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t},\n\t\t\tNodeType::Int(val) => match *rhs {\n\t\t\t\tNodeType::Str(val2) => Box::new(NodeType::Str(Box::new(format!(\"{val}{val2}\")))),\n\t\t\t\tNodeType::Int(val2) => Box::new(NodeType::Bool(Box::new(*val != 0 && *val2 != 0))),\n\t\t\t\tNodeType::Float(val2) => Box::new(NodeType::Bool(Box::new(*val != 0 && *val2 != 0.0))),\n\t\t\t\tNodeType::Bool(val2) => Box::new(NodeType::Bool(Box::new(*val != 0 && *val2))),\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t},\n\t\t\tNodeType::Float(val) => match *rhs {\n\t\t\t\tNodeType::Str(val2) => Box::new(NodeType::Str(Box::new(format!(\"{val}{val2}\")))),\n\t\t\t\tNodeType::Int(val2) => Box::new(NodeType::Bool(Box::new(*val != 0.0 && *val2 != 0))),\n\t\t\t\tNodeType::Float(val2) => Box::new(NodeType::Bool(Box::new(*val != 0.0 && *val2 != 0.0))),\n\t\t\t\tNodeType::Bool(val2) => Box::new(NodeType::Bool(Box::new(*val != 0.0&& *val2))),\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t},\n\t\t\tNodeType::Bool(val) => match *rhs {\n\t\t\t\tNodeType::Str(val2) => Box::new(NodeType::Str(Box::new(format!(\"{val}{val2}\")))),\n\t\t\t\tNodeType::Int(val2) => Box::new(NodeType::Bool(Box::new(*val && if *val2 >= 1 {true} else {false}))),\n\t\t\t\tNodeType::Float(val2) => Box::new(NodeType::Bool(Box::new(*val && if *val2 >= 1.0 {true} else {false}))),\n\t\t\t\tNodeType::Bool(val2) => Box::new(NodeType::Bool(Box::new(*val && *val2))),\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t},\n\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t}\n\t}\n\n\tpub fn or(&mut self, lhs:Box<NodeType>, rhs:Box<NodeType>) -> Box<NodeType> {\n\t\tmatch *lhs {\n\t\t\tNodeType::Str(val) => match *rhs {\n\t\t\t\tNodeType::Str(val2) => Box::new(NodeType::Str(Box::new(format!(\"{val}{val2}\")))),\n\t\t\t\tNodeType::Int(val2) => Box::new(NodeType::Str(Box::new(format!(\"{val}{val2}\")))),\n\t\t\t\tNodeType::Float(val2) => Box::new(NodeType::Str(Box::new(format!(\"{val}{val2}\")))),\n\t\t\t\tNodeType::Bool(val2) => Box::new(NodeType::Str(Box::new(format!(\"{val}{val2}\")))),\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t},\n\t\t\tNodeType::Int(val) => match *rhs {\n\t\t\t\tNodeType::Str(val2) => Box::new(NodeType::Str(Box::new(format!(\"{val}{val2}\")))),\n\t\t\t\tNodeType::Int(val2) => Box::new(NodeType::Bool(Box::new(*val != 0 || *val2 != 0))),\n\t\t\t\tNodeType::Float(val2) => Box::new(NodeType::Bool(Box::new(*val != 0 || *val2 != 0.0))),\n\t\t\t\tNodeType::Bool(val2) => Box::new(NodeType::Bool(Box::new(*val != 0 || *val2))),\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t},\n\t\t\tNodeType::Float(val) => match *rhs {\n\t\t\t\tNodeType::Str(val2) => Box::new(NodeType::Str(Box::new(format!(\"{val}{val2}\")))),\n\t\t\t\tNodeType::Int(val2) => Box::new(NodeType::Bool(Box::new(*val != 0.0 || *val2 != 0))),\n\t\t\t\tNodeType::Float(val2) => Box::new(NodeType::Bool(Box::new(*val != 0.0 || *val2 != 0.0))),\n\t\t\t\tNodeType::Bool(val2) => Box::new(NodeType::Bool(Box::new(*val != 0.0 || *val2))),\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t},\n\t\t\tNodeType::Bool(val) => match *rhs {\n\t\t\t\tNodeType::Str(val2) => Box::new(NodeType::Str(Box::new(format!(\"{val}{val2}\")))),\n\t\t\t\tNodeType::Int(val2) => Box::new(NodeType::Bool(Box::new(*val || if *val2 >= 1 {true} else {false}))),\n\t\t\t\tNodeType::Float(val2) => Box::new(NodeType::Bool(Box::new(*val || if *val2 >= 1.0 {true} else {false}))),\n\t\t\t\tNodeType::Bool(val2) => Box::new(NodeType::Bool(Box::new(*val || *val2))),\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t},\n\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t}\n\t}\n\n\tpub fn sub(&mut self, lhs:Box<NodeType>, rhs:Box<NodeType>) -> Box<NodeType> {\n\t\tmatch *lhs {\n\t\t\tNodeType::Str(mut val) => match *rhs {\n\t\t\t\tNodeType::Str(val2) => Box::new(NodeType::Str(Box::new(val.replace(&*val2, \"\")))),\n\t\t\t\tNodeType::Int(val2) => {\n\t\t\t\t\tfor _ in 0..*val2 {\n\t\t\t\t\t\tval.pop();\n\t\t\t\t\t}\n\t\t\t\t\treturn Box::new(NodeType::Str(Box::new(*val)));\n\t\t\t\t},\n\t\t\t\tNodeType::Float(val2) => {\n\t\t\t\t\tfor _ in 0..*val2 as i128 {\n\t\t\t\t\t\tval.pop();\n\t\t\t\t\t}\n\t\t\t\t\treturn Box::new(NodeType::Str(Box::new(*val)));\n\t\t\t\t},\n\t\t\t\tNodeType::Bool(_) => {\n\t\t\t\t\tBox::new(NodeType::Bool(Box::new(false)))\n\t\t\t\t},\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t},\n\t\t\tNodeType::Int(val) => match *rhs {\n\t\t\t\tNodeType::Str(val2) => Box::new(NodeType::Str(Box::new(format!(\"{val}{val2}\")))),\n\t\t\t\tNodeType::Int(val2) => Box::new(NodeType::Int(Box::new(*val - *val2))),\n\t\t\t\tNodeType::Float(val2) => Box::new(NodeType::Int(Box::new(*val - *val2 as i128))),\n\t\t\t\tNodeType::Bool(val2) => Box::new(NodeType::Int(Box::new(*val - *val2 as i128))),\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t},\n\t\t\tNodeType::Float(val) => match *rhs {\n\t\t\t\tNodeType::Str(val2) => Box::new(NodeType::Str(Box::new(format!(\"{val}{val2}\")))),\n\t\t\t\tNodeType::Int(val2) => Box::new(NodeType::Float(Box::new(*val - *val2 as f64))),\n\t\t\t\tNodeType::Float(val2) => Box::new(NodeType::Float(Box::new(*val - *val2 as f64))),\n\t\t\t\tNodeType::Bool(val2) => Box::new(NodeType::Float(Box::new(*val - if *val2 {1.0} else {0.0}))),\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t},\n\t\t\tNodeType::Bool(val) => match *rhs {\n\t\t\t\tNodeType::Str(val2) => Box::new(NodeType::Str(Box::new(format!(\"{val}{val2}\")))),\n\t\t\t\tNodeType::Int(val2) => Box::new(NodeType::Bool(Box::new(!(*val && if *val2 >= 1 {true} else {false})))),\n\t\t\t\tNodeType::Float(val2) => Box::new(NodeType::Bool(Box::new(!(*val && if *val2 >= 1.0 {true} else {false})))),\n\t\t\t\tNodeType::Bool(val2) => Box::new(NodeType::Bool(Box::new(!(*val && *val2)))),\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t},\n\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t}\n\t}\n\n\tpub fn mul(&mut self, lhs:Box<NodeType>, rhs:Box<NodeType>) -> Box<NodeType> {\n\t\tmatch *lhs {\n\t\t\tNodeType::Str(mut val) => match *rhs {\n\t\t\t\tNodeType::Str(val2) => Box::new(NodeType::Str(Box::new(val.replace(&*val2, \"\")))),\n\t\t\t\tNodeType::Int(val2) => {\n\t\t\t\t\tlet ret = val.clone();\n\t\t\t\t\tfor _ in 0..*val2 {\n\t\t\t\t\t\t*val = format!(\"{ret}{ret}\");\n\t\t\t\t\t}\n\t\t\t\t\treturn Box::new(NodeType::Str(Box::new(*val)));\n\t\t\t\t},\n\t\t\t\tNodeType::Float(val2) => {\n\t\t\t\t\tlet ret = val.clone();\n\t\t\t\t\tfor _ in 0..*val2 as i128 {\n\t\t\t\t\t\t*val = format!(\"{ret}{ret}\");\n\t\t\t\t\t}\n\t\t\t\t\treturn Box::new(NodeType::Str(Box::new(*val)));\n\t\t\t\t},\n\t\t\t\tNodeType::Bool(_) => {\n\t\t\t\t\tBox::new(NodeType::Bool(Box::new(false)))\n\t\t\t\t},\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t},\n\t\t\tNodeType::Int(val) => match *rhs {\n\t\t\t\tNodeType::Str(val2) => Box::new(NodeType::Str(Box::new(format!(\"{val}{val2}\")))),\n\t\t\t\tNodeType::Int(val2) => Box::new(NodeType::Int(Box::new(*val * *val2))),\n\t\t\t\tNodeType::Float(val2) => Box::new(NodeType::Int(Box::new(*val * *val2 as i128))),\n\t\t\t\tNodeType::Bool(val2) => Box::new(NodeType::Int(Box::new(*val * *val2 as i128))),\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t},\n\t\t\tNodeType::Float(val) => match *rhs {\n\t\t\t\tNodeType::Str(val2) => Box::new(NodeType::Str(Box::new(format!(\"{val}{val2}\")))),\n\t\t\t\tNodeType::Int(val2) => Box::new(NodeType::Float(Box::new(*val * *val2 as f64))),\n\t\t\t\tNodeType::Float(val2) => Box::new(NodeType::Float(Box::new(*val * *val2 as f64))),\n\t\t\t\tNodeType::Bool(val2) => Box::new(NodeType::Float(Box::new(*val * if *val2 {1.0} else {0.0}))),\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t},\n\t\t\tNodeType::Bool(val) => match *rhs {\n\t\t\t\tNodeType::Str(val2) => Box::new(NodeType::Str(Box::new(format!(\"{val}{val2}\")))),\n\t\t\t\tNodeType::Int(val2) => Box::new(NodeType::Bool(Box::new(*val || if *val2 >= 1 {true} else {false}))),\n\t\t\t\tNodeType::Float(val2) => Box::new(NodeType::Bool(Box::new(*val || if *val2 >= 1.0 {true} else {false}))),\n\t\t\t\tNodeType::Bool(val2) => Box::new(NodeType::Bool(Box::new(*val || *val2))),\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t},\n\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t}\n\t}\n\n\tpub fn div(&mut self, lhs:Box<NodeType>, rhs:Box<NodeType>) -> Box<NodeType> {\n\t\tmatch *lhs {\n\t\t\tNodeType::Str(mut val) => match *rhs {\n\t\t\t\tNodeType::Str(val2) => Box::new(NodeType::Str(Box::new(val.replace(&*val2, \"\")))),\n\t\t\t\tNodeType::Int(val2) => {\n\t\t\t\t\tlet ret = val.clone();\n\t\t\t\t\tfor _ in 0..*val2 {\n\t\t\t\t\t\t*val = format!(\"{ret}{ret}\");\n\t\t\t\t\t}\n\t\t\t\t\treturn Box::new(NodeType::Str(Box::new(*val)));\n\t\t\t\t},\n\t\t\t\tNodeType::Float(val2) => {\n\t\t\t\t\tlet ret = val.clone();\n\t\t\t\t\tfor _ in 0..*val2 as i128 {\n\t\t\t\t\t\t*val = format!(\"{ret}{ret}\");\n\t\t\t\t\t}\n\t\t\t\t\treturn Box::new(NodeType::Str(Box::new(*val)));\n\t\t\t\t},\n\t\t\t\tNodeType::Bool(_) => {\n\t\t\t\t\tBox::new(NodeType::Bool(Box::new(false)))\n\t\t\t\t},\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t},\n\t\t\tNodeType::Int(val) => match *rhs {\n\t\t\t\tNodeType::Str(val2) => Box::new(NodeType::Str(Box::new(format!(\"{val}{val2}\")))),\n\t\t\t\tNodeType::Int(val2) => Box::new(NodeType::Int(Box::new(*val / *val2))),\n\t\t\t\tNodeType::Float(val2) => Box::new(NodeType::Int(Box::new(*val / *val2 as i128))),\n\t\t\t\tNodeType::Bool(val2) => Box::new(NodeType::Int(Box::new(*val / *val2 as i128))),\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t},\n\t\t\tNodeType::Float(val) => match *rhs {\n\t\t\t\tNodeType::Str(val2) => Box::new(NodeType::Str(Box::new(format!(\"{val}{val2}\")))),\n\t\t\t\tNodeType::Int(val2) => Box::new(NodeType::Float(Box::new(*val / *val2 as f64))),\n\t\t\t\tNodeType::Float(val2) => Box::new(NodeType::Float(Box::new(*val / *val2 as f64))),\n\t\t\t\tNodeType::Bool(val2) => Box::new(NodeType::Float(Box::new(*val / if *val2 {1.0} else {0.0}))),\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t},\n\t\t\tNodeType::Bool(val) => match *rhs {\n\t\t\t\tNodeType::Str(val2) => Box::new(NodeType::Str(Box::new(format!(\"{val}{val2}\")))),\n\t\t\t\tNodeType::Int(val2) => Box::new(NodeType::Bool(Box::new(!(*val || if *val2 >= 1 {true} else {false})))),\n\t\t\t\tNodeType::Float(val2) => Box::new(NodeType::Bool(Box::new(!(*val || if *val2 >= 1.0 {true} else {false})))),\n\t\t\t\tNodeType::Bool(val2) => Box::new(NodeType::Bool(Box::new(!(*val || *val2)))),\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t},\n\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t}\n\t}\n\n\tpub fn read(&mut self, filepath:Box<NodeType>) -> Box<NodeType> {\n\t\tlet path = PathBuf::from(self.file_path.clone());\n\t\tlet dir = path.parent().unwrap();\n\t\t\n\t\tmatch *filepath {\n\t\t\tNodeType::Str(val) => {\n\t\t\t\t//println!(\"{}\", dir.join(*val.clone()).display());\n\t\t\t\tBox::new(NodeType::Str(Box::new(fs::read_to_string(dir.join(*val)).unwrap())))\n\t\t\t},\n\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t}\n\t}\n\tpub fn filewrite(&mut self, filepath:Box<NodeType>, content:Box<NodeType>, writemode:Box<NodeType>) -> Box<NodeType> {\n\t\tlet path = PathBuf::from(self.file_path.clone());\n\t\tlet dir = path.parent().unwrap();\n\t\tmatch *filepath.clone() {\n\t\t\tNodeType::Str(filep) => {\n\t\t\t\tmatch *writemode.clone() {\n\t\t\t\t\tNodeType::Str(wm) => {\n\t\t\t\t\t\tmatch *content.clone() {\n\t\t\t\t\t\t\tNodeType::Str(cont) => {\n\t\t\t\t\t\t\t\tuse std::io::Write;\n\t\t\t\t\t\t\t\tlet mut file:File;\n\t\t\t\t\t\t\t\tlet mut openopt:&mut OpenOptions = &mut OpenOptions::new();\n\t\t\t\t\t\t\t\tmatch &*wm.to_lowercase().as_str() {\n\t\t\t\t\t\t\t\t\t\"a\" => {\n\t\t\t\t\t\t\t\t\t\topenopt = openopt.write(true).create(true).append(true);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\"t\" => {\n\t\t\t\t\t\t\t\t\t\topenopt = openopt.write(true).create(true).truncate(true);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t_ => {}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tmatch openopt.open(dir.join(*filep)) {\n\t\t\t\t\t\t\t\t\tOk(val) => {\n\t\t\t\t\t\t\t\t\t\tfile = val;\n\t\t\t\t\t\t\t\t\t\twrite!(file, \"{}\", cont).ok();\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tErr(val) => {\n\t\t\t\t\t\t\t\t\t\teprintln!(\"{val}\");\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t_ => {},\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t_ => {},\n\t\t\t\t}\n\t\t\t},\n\t\t\t_ => {},\n\t\t}\n\t\t\n\t\tBox::new(NodeType::Bool(Box::new(false)))\n\t}\n\n\tpub fn equal(&mut self, lhs:Box<StackNode>, rhs:Box<StackNode>) -> Box<NodeType> {\n\t\tmatch *lhs.ntype {\n\t\t\tNodeType::Str(val) => match *rhs.ntype {\n\t\t\t\tNodeType::Str(val2) => Box::new(NodeType::Bool(Box::new(*val == *val2))),\n\t\t\t\tNodeType::Int(val2) => Box::new(NodeType::Bool(Box::new(*val == format!(\"{val2}\")))),\n\t\t\t\tNodeType::Float(val2) => Box::new(NodeType::Bool(Box::new(*val == format!(\"{val2}\")))),\n\t\t\t\tNodeType::Bool(val2) => Box::new(NodeType::Bool(Box::new(*val == format!(\"{val2}\")))),\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t},\n\t\t\tNodeType::Int(val) => match *rhs.ntype {\n\t\t\t\tNodeType::Str(val2) => Box::new(NodeType::Bool(Box::new(*val2 == format!(\"{val}\")))),\n\t\t\t\tNodeType::Int(val2) => Box::new(NodeType::Bool(Box::new(*val == *val2))),\n\t\t\t\tNodeType::Float(val2) => Box::new(NodeType::Bool(Box::new(*val == *val2 as i128))),\n\t\t\t\tNodeType::Bool(val2) => Box::new(NodeType::Bool(Box::new(*val == *val2 as i128))),\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t},\n\t\t\tNodeType::Float(val) => match *rhs.ntype {\n\t\t\t\tNodeType::Str(val2) => Box::new(NodeType::Bool(Box::new(*val2 == format!(\"{val}\")))),\n\t\t\t\tNodeType::Int(val2) => Box::new(NodeType::Bool(Box::new(*val == *val2 as f64))),\n\t\t\t\tNodeType::Float(val2) => Box::new(NodeType::Bool(Box::new(*val == *val2 as f64))),\n\t\t\t\tNodeType::Bool(val2) => Box::new(NodeType::Bool(Box::new(*val == if *val2 {1.0} else {0.0}))),\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t},\n\t\t\tNodeType::Bool(val) => match *rhs.ntype {\n\t\t\t\tNodeType::Str(val2) => Box::new(NodeType::Bool(Box::new(*val2 == format!(\"{val}\")))),\n\t\t\t\tNodeType::Int(val2) => Box::new(NodeType::Bool(Box::new(*val == if *val2 >= 1 {true} else {false}))),\n\t\t\t\tNodeType::Float(val2) => Box::new(NodeType::Bool(Box::new(*val == if *val2 >= 1.0 {true} else {false}))),\n\t\t\t\tNodeType::Bool(val2) => Box::new(NodeType::Bool(Box::new(*val == *val2))),\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t}\n\t\t\tNodeType::Vector => match *rhs.ntype {\n\t\t\t\tNodeType::Vector => Box::new(NodeType::Bool(Box::new(lhs.args.iter().zip(&*rhs.args).all(|(a, b)| **a == **b)))),\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t}\n\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t}\n\t}\n\n\tpub fn notequal(&mut self, lhs:Box<StackNode>, rhs:Box<StackNode>) -> Box<NodeType> {\n\t\tmatch *lhs.ntype {\n\t\t\tNodeType::Str(val) => match *rhs.ntype {\n\t\t\t\tNodeType::Str(val2) => Box::new(NodeType::Bool(Box::new(*val != *val2))),\n\t\t\t\tNodeType::Int(val2) => Box::new(NodeType::Bool(Box::new(*val != format!(\"{val2}\")))),\n\t\t\t\tNodeType::Float(val2) => Box::new(NodeType::Bool(Box::new(*val != format!(\"{val2}\")))),\n\t\t\t\tNodeType::Bool(val2) => Box::new(NodeType::Bool(Box::new(*val != format!(\"{val2}\")))),\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t},\n\t\t\tNodeType::Int(val) => match *rhs.ntype {\n\t\t\t\tNodeType::Str(val2) => Box::new(NodeType::Bool(Box::new(*val2 != format!(\"{val}\")))),\n\t\t\t\tNodeType::Int(val2) => Box::new(NodeType::Bool(Box::new(*val != *val2))),\n\t\t\t\tNodeType::Float(val2) => Box::new(NodeType::Bool(Box::new(*val != *val2 as i128))),\n\t\t\t\tNodeType::Bool(val2) => Box::new(NodeType::Bool(Box::new(*val != *val2 as i128))),\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t},\n\t\t\tNodeType::Float(val) => match *rhs.ntype {\n\t\t\t\tNodeType::Str(val2) => Box::new(NodeType::Bool(Box::new(*val2 != format!(\"{val}\")))),\n\t\t\t\tNodeType::Int(val2) => Box::new(NodeType::Bool(Box::new(*val != *val2 as f64))),\n\t\t\t\tNodeType::Float(val2) => Box::new(NodeType::Bool(Box::new(*val != *val2 as f64))),\n\t\t\t\tNodeType::Bool(val2) => Box::new(NodeType::Bool(Box::new(*val != if *val2 {1.0} else {0.0}))),\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t},\n\t\t\tNodeType::Bool(val) => match *rhs.ntype {\n\t\t\t\tNodeType::Str(val2) => Box::new(NodeType::Str(Box::new((*val2 != format!(\"{val}\")).to_string()))),\n\t\t\t\tNodeType::Int(val2) => Box::new(NodeType::Bool(Box::new(*val != if *val2 >= 1 {true} else {false}))),\n\t\t\t\tNodeType::Float(val2) => Box::new(NodeType::Bool(Box::new(*val != if *val2 >= 1.0 {true} else {false}))),\n\t\t\t\tNodeType::Bool(val2) => Box::new(NodeType::Bool(Box::new(*val != *val2))),\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t},\n\t\t\tNodeType::Vector => match *rhs.ntype {\n\t\t\t\tNodeType::Vector => Box::new(NodeType::Bool(Box::new(!lhs.args.iter().zip(&*rhs.args).all(|(a, b)| **a == **b)))),\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t}\n\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t}\n\t}\n\n\tpub fn greater(&mut self, lhs:Box<NodeType>, rhs:Box<NodeType>) -> Box<NodeType> {\n\t\tmatch *lhs {\n\t\t\tNodeType::Str(val) => match *rhs {\n\t\t\t\tNodeType::Str(val2) => Box::new(NodeType::Bool(Box::new(*val > *val2))),\n\t\t\t\tNodeType::Int(val2) => Box::new(NodeType::Bool(Box::new(*val > format!(\"{val2}\")))),\n\t\t\t\tNodeType::Float(val2) => Box::new(NodeType::Bool(Box::new(*val > format!(\"{val2}\")))),\n\t\t\t\tNodeType::Bool(val2) => Box::new(NodeType::Bool(Box::new(*val > format!(\"{val2}\")))),\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t},\n\t\t\tNodeType::Int(val) => match *rhs {\n\t\t\t\tNodeType::Str(val2) => Box::new(NodeType::Bool(Box::new(*val2 > format!(\"{val}\")))),\n\t\t\t\tNodeType::Int(val2) => Box::new(NodeType::Bool(Box::new(*val > *val2))),\n\t\t\t\tNodeType::Float(val2) => Box::new(NodeType::Bool(Box::new(*val > *val2 as i128))),\n\t\t\t\tNodeType::Bool(val2) => Box::new(NodeType::Bool(Box::new(*val > *val2 as i128))),\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t},\n\t\t\tNodeType::Float(val) => match *rhs {\n\t\t\t\tNodeType::Str(val2) => Box::new(NodeType::Bool(Box::new(*val2 > format!(\"{val}\")))),\n\t\t\t\tNodeType::Int(val2) => Box::new(NodeType::Bool(Box::new(*val > *val2 as f64))),\n\t\t\t\tNodeType::Float(val2) => Box::new(NodeType::Bool(Box::new(*val > *val2 as f64))),\n\t\t\t\tNodeType::Bool(val2) => Box::new(NodeType::Bool(Box::new(*val > if *val2 {1.0} else {0.0}))),\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t},\n\t\t\tNodeType::Bool(val) => match *rhs {\n\t\t\t\tNodeType::Str(val2) => Box::new(NodeType::Str(Box::new((*val2 > format!(\"{val}\")).to_string()))),\n\t\t\t\tNodeType::Int(val2) => Box::new(NodeType::Bool(Box::new(*val > if *val2 >= 1 {true} else {false}))),\n\t\t\t\tNodeType::Float(val2) => Box::new(NodeType::Bool(Box::new(*val > if *val2 >= 1.0 {true} else {false}))),\n\t\t\t\tNodeType::Bool(val2) => Box::new(NodeType::Bool(Box::new(*val > *val2))),\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t},\n\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t}\n\t}\n\n\tpub fn less(&mut self, lhs:Box<NodeType>, rhs:Box<NodeType>) -> Box<NodeType> {\n\t\tmatch *lhs {\n\t\t\tNodeType::Str(val) => match *rhs {\n\t\t\t\tNodeType::Str(val2) => Box::new(NodeType::Bool(Box::new(*val < *val2))),\n\t\t\t\tNodeType::Int(val2) => Box::new(NodeType::Bool(Box::new(*val < format!(\"{val2}\")))),\n\t\t\t\tNodeType::Float(val2) => Box::new(NodeType::Bool(Box::new(*val < format!(\"{val2}\")))),\n\t\t\t\tNodeType::Bool(val2) => Box::new(NodeType::Bool(Box::new(*val < format!(\"{val2}\")))),\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t},\n\t\t\tNodeType::Int(val) => match *rhs {\n\t\t\t\tNodeType::Str(val2) => Box::new(NodeType::Bool(Box::new(*val2 < format!(\"{val}\")))),\n\t\t\t\tNodeType::Int(val2) => Box::new(NodeType::Bool(Box::new(*val < *val2))),\n\t\t\t\tNodeType::Float(val2) => Box::new(NodeType::Bool(Box::new(*val < *val2 as i128))),\n\t\t\t\tNodeType::Bool(val2) => Box::new(NodeType::Bool(Box::new(*val < *val2 as i128))),\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t},\n\t\t\tNodeType::Float(val) => match *rhs {\n\t\t\t\tNodeType::Str(val2) => Box::new(NodeType::Bool(Box::new(*val2 < format!(\"{val}\")))),\n\t\t\t\tNodeType::Int(val2) => Box::new(NodeType::Bool(Box::new(*val < *val2 as f64))),\n\t\t\t\tNodeType::Float(val2) => Box::new(NodeType::Bool(Box::new(*val < *val2 as f64))),\n\t\t\t\tNodeType::Bool(val2) => Box::new(NodeType::Bool(Box::new(*val < if *val2 {1.0} else {0.0}))),\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t},\n\t\t\tNodeType::Bool(val) => match *rhs {\n\t\t\t\tNodeType::Str(val2) => Box::new(NodeType::Str(Box::new((*val2 < format!(\"{val}\")).to_string()))),\n\t\t\t\tNodeType::Int(val2) => Box::new(NodeType::Bool(Box::new(*val < if *val2 >= 1 {true} else {false}))),\n\t\t\t\tNodeType::Float(val2) => Box::new(NodeType::Bool(Box::new(*val < if *val2 >= 1.0 {true} else {false}))),\n\t\t\t\tNodeType::Bool(val2) => Box::new(NodeType::Bool(Box::new(*val < *val2))),\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t},\n\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t}\n\t}\n\n\tpub fn lessequal(&mut self, lhs:Box<NodeType>, rhs:Box<NodeType>) -> Box<NodeType> {\n\t\tmatch *lhs {\n\t\t\tNodeType::Str(val) => match *rhs {\n\t\t\t\tNodeType::Str(val2) => Box::new(NodeType::Bool(Box::new(*val <= *val2))),\n\t\t\t\tNodeType::Int(val2) => Box::new(NodeType::Bool(Box::new(*val <= format!(\"{val2}\")))),\n\t\t\t\tNodeType::Float(val2) => Box::new(NodeType::Bool(Box::new(*val <= format!(\"{val2}\")))),\n\t\t\t\tNodeType::Bool(val2) => Box::new(NodeType::Bool(Box::new(*val <= format!(\"{val2}\")))),\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t},\n\t\t\tNodeType::Int(val) => match *rhs {\n\t\t\t\tNodeType::Str(val2) => Box::new(NodeType::Bool(Box::new(*val2 <= format!(\"{val}\")))),\n\t\t\t\tNodeType::Int(val2) => Box::new(NodeType::Bool(Box::new(*val <= *val2))),\n\t\t\t\tNodeType::Float(val2) => Box::new(NodeType::Bool(Box::new(*val <= *val2 as i128))),\n\t\t\t\tNodeType::Bool(val2) => Box::new(NodeType::Bool(Box::new(*val <= *val2 as i128))),\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t},\n\t\t\tNodeType::Float(val) => match *rhs {\n\t\t\t\tNodeType::Str(val2) => Box::new(NodeType::Bool(Box::new(*val2 <= format!(\"{val}\")))),\n\t\t\t\tNodeType::Int(val2) => Box::new(NodeType::Bool(Box::new(*val <= *val2 as f64))),\n\t\t\t\tNodeType::Float(val2) => Box::new(NodeType::Bool(Box::new(*val <= *val2 as f64))),\n\t\t\t\tNodeType::Bool(val2) => Box::new(NodeType::Bool(Box::new(*val <= if *val2 {1.0} else {0.0}))),\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t},\n\t\t\tNodeType::Bool(val) => match *rhs {\n\t\t\t\tNodeType::Str(val2) => Box::new(NodeType::Str(Box::new((*val2 <= format!(\"{val}\")).to_string()))),\n\t\t\t\tNodeType::Int(val2) => Box::new(NodeType::Bool(Box::new(*val <= if *val2 >= 1 {true} else {false}))),\n\t\t\t\tNodeType::Float(val2) => Box::new(NodeType::Bool(Box::new(*val <= if *val2 >= 1.0 {true} else {false}))),\n\t\t\t\tNodeType::Bool(val2) => Box::new(NodeType::Bool(Box::new(*val <= *val2))),\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t},\n\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t}\n\t}\n\n\tpub fn greaterequal(&mut self, lhs:Box<NodeType>, rhs:Box<NodeType>) -> Box<NodeType> {\n\t\tmatch *lhs {\n\t\t\tNodeType::Str(val) => match *rhs {\n\t\t\t\tNodeType::Str(val2) => Box::new(NodeType::Bool(Box::new(*val >= *val2))),\n\t\t\t\tNodeType::Int(val2) => Box::new(NodeType::Bool(Box::new(*val >= format!(\"{val2}\")))),\n\t\t\t\tNodeType::Float(val2) => Box::new(NodeType::Bool(Box::new(*val >= format!(\"{val2}\")))),\n\t\t\t\tNodeType::Bool(val2) => Box::new(NodeType::Bool(Box::new(*val >= format!(\"{val2}\")))),\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t},\n\t\t\tNodeType::Int(val) => match *rhs {\n\t\t\t\tNodeType::Str(val2) => Box::new(NodeType::Bool(Box::new(*val2 >= format!(\"{val}\")))),\n\t\t\t\tNodeType::Int(val2) => Box::new(NodeType::Bool(Box::new(*val >= *val2))),\n\t\t\t\tNodeType::Float(val2) => Box::new(NodeType::Bool(Box::new(*val >= *val2 as i128))),\n\t\t\t\tNodeType::Bool(val2) => Box::new(NodeType::Bool(Box::new(*val >= *val2 as i128))),\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t},\n\t\t\tNodeType::Float(val) => match *rhs {\n\t\t\t\tNodeType::Str(val2) => Box::new(NodeType::Bool(Box::new(*val2 >= format!(\"{val}\")))),\n\t\t\t\tNodeType::Int(val2) => Box::new(NodeType::Bool(Box::new(*val >= *val2 as f64))),\n\t\t\t\tNodeType::Float(val2) => Box::new(NodeType::Bool(Box::new(*val >= *val2 as f64))),\n\t\t\t\tNodeType::Bool(val2) => Box::new(NodeType::Bool(Box::new(*val >= if *val2 {1.0} else {0.0}))),\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t},\n\t\t\tNodeType::Bool(val) => match *rhs {\n\t\t\t\tNodeType::Str(val2) => Box::new(NodeType::Str(Box::new((*val2 >= format!(\"{val}\")).to_string()))),\n\t\t\t\tNodeType::Int(val2) => Box::new(NodeType::Bool(Box::new(*val >= if *val2 >= 1 {true} else {false}))),\n\t\t\t\tNodeType::Float(val2) => Box::new(NodeType::Bool(Box::new(*val >= if *val2 >= 1.0 {true} else {false}))),\n\t\t\t\tNodeType::Bool(val2) => Box::new(NodeType::Bool(Box::new(*val >= *val2))),\n\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t},\n\t\t\t_ => {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t}\n\t}\n\n\tpub fn contains_operator(&mut self, lhs:&mut Box<StackNode>, rhs:Box<StackNode>) -> Box<NodeType> {\n\t\tmatch *rhs.ntype.clone() {\n\t\t\tNodeType::Str(val) => {\n\t\t\t\tmatch *lhs.ntype.clone() {\n\t\t\t\t\tNodeType::Str(val2) => {\n\t\t\t\t\t\treturn Box::new(NodeType::Bool(Box::new(val.contains(&*val2))));\n\t\t\t\t\t}\n\t\t\t\t\tNodeType::Int(val2) => {\n\t\t\t\t\t\treturn Box::new(NodeType::Bool(Box::new(val.contains(&format!(\"{val2}\")))));\n\t\t\t\t\t}\n\t\t\t\t\tNodeType::Float(val2) => {\n\t\t\t\t\t\treturn Box::new(NodeType::Bool(Box::new(val.contains(&format!(\"{val2}\")))));\n\t\t\t\t\t}\n\t\t\t\t\t_ => {\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tNodeType::Vector => {\n\t\t\t\tfor item in rhs.args.iter() {\n\t\t\t\t\tif item == lhs {\n\t\t\t\t\t\treturn Box::new(NodeType::Bool(Box::new(false)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t_ => todo!(),\n\t\t}\n\t\tBox::new(NodeType::Bool(Box::new(false)))\n\t}\n\n\tpub fn cat(&mut self, args_list:Box<Vec<Box<StackNode>>>) -> Box<NodeType> {\n\t\tif args_list.len() == 0 {\n\t\t\tprintln!(\"Meow!\");\n\t\t}\n\t\tlet mut ret = String::new();\n\t\tfor arg in args_list.iter() {\n\t\t\tmatch *arg.ntype.clone() {\n\t\t\t\tNodeType::Str(val) => ret = format!(\"{ret}{val}\"),\n\t\t\t\tNodeType::Int(val) => ret = format!(\"{ret}{val}\"),\n\t\t\t\tNodeType::Float(val) => ret = format!(\"{ret}{val}\"),\n\t\t\t\tNodeType::Bool(val) => ret = format!(\"{ret}{val}\"),\n\t\t\t\t_ => {},\n\t\t\t}\n\t\t}\n\t\treturn Box::new(NodeType::Str(Box::new(ret)));\n\t}\n\n\tpub fn foreign_function_interface(&mut self, args_list:Box<Vec<Box<StackNode>>>) -> Box<NodeType> {\n\t\treturn Box::new(NodeType::Str(Box::new(String::new())));\n\t}\n\n\tpub fn split(&mut self, args_list:Box<Vec<Box<StackNode>>>) -> Box<StackNode> {\n\t\tlet mut vector = StackNode {\n\t\t\toperation: Box::new(String::new()),\n\t\t\tntype: Box::new(NodeType::Vector),\n\t\t\targs: Box::new(vec![]),\n\t\t\tscope: Box::new(vec![]),\n\t\t};\n\t\tmatch *args_list[0].ntype.clone() {\n\t\t\tNodeType::Str(val) => match *args_list[1].ntype.clone() {\n\t\t\t\tNodeType::Str(val2) => {\n\t\t\t\t\tfor substr in val.split(val2.as_str()) {\n\t\t\t\t\t\tvector.args.push(Box::new(StackNode {\n\t\t\t\t\t\t\toperation: Box::new(String::new()),\n\t\t\t\t\t\t\tntype: Box::new(NodeType::Str(Box::new(String::from(substr)))),\n\t\t\t\t\t\t\targs: Box::new(vec![]),\n\t\t\t\t\t\t\tscope: Box::new(vec![]),\n\t\t\t\t\t\t}));\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t_ => {},\n\t\t\t},\n\t\t\t_ => {},\n\t\t}\n\t\treturn Box::new(vector);\n\t}\n\n\tpub fn remove_ws(&mut self, args_list:Box<Vec<Box<StackNode>>>) -> Box<NodeType> {\n\t\treturn Box::new(NodeType::Str(Box::new(match *args_list[0].ntype.clone() {\n\t\t\tNodeType::Str(val) => String::from(val.trim()),\n\t\t\t_ => {String::new()},\n\t\t})));\n\t}\n\n\tpub fn replace(&mut self, args_list:Box<Vec<Box<StackNode>>>) -> Box<NodeType> {\n\t\treturn Box::new(NodeType::Str(Box::new(match *args_list[0].ntype.clone() {\n\t\t\tNodeType::Str(val) => {\n\t\t\t\tmatch *args_list[1].ntype.clone() {\n\t\t\t\t\tNodeType::Str(val1) => {\n\t\t\t\t\t\tmatch *args_list[2].ntype.clone() {\n\t\t\t\t\t\t\tNodeType::Str(val2) => {\n\t\t\t\t\t\t\t\tString::from(val.replace(val1.as_str(), val2.as_str()))\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t_ => {String::new()},\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t_ => {String::new()},\n\t\t\t\t}\n\t\t\t},\n\t\t\t_ => {String::new()},\n\t\t})));\n\t}\n\n\tpub fn push_to_array(&mut self, node:Box<StackNode>, args_list:Box<Vec<Box<StackNode>>>) {\n\t\tfor layer in self.stack.iter_mut().rev() {\n\t\t\tif layer.contains_key(node.args[0].operation.clone().as_str()) {\n\t\t\t\tmatch *layer.get(&*node.args[0].operation).unwrap().ntype.clone() {\n\t\t\t\t\tNodeType::Str(val) => {\n\t\t\t\t\t\tmatch *args_list[1].ntype.clone() {\n\t\t\t\t\t\t\tNodeType::Str(val2) => {\n\t\t\t\t\t\t\t\tlayer.get_mut(&*node.args[0].operation).unwrap().ntype = Box::new(NodeType::Str(Box::new(format!(\"{val}{val2}\"))));\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tNodeType::Int(val2) => {\n\t\t\t\t\t\t\t\tlayer.get_mut(&*node.args[0].operation).unwrap().ntype = Box::new(NodeType::Str(Box::new(format!(\"{val}{val2}\"))));\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tNodeType::Float(val2) => {\n\t\t\t\t\t\t\t\tlayer.get_mut(&*node.args[0].operation).unwrap().ntype = Box::new(NodeType::Str(Box::new(format!(\"{val}{val2}\"))));\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tNodeType::Bool(val2) => {\n\t\t\t\t\t\t\t\tlayer.get_mut(&*node.args[0].operation).unwrap().ntype = Box::new(NodeType::Str(Box::new(format!(\"{val}{val2}\"))));\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t_ => {\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tNodeType::Vector => {\n\t\t\t\t\t\tlayer.get_mut(&*node.args[0].operation).unwrap().args.push(args_list[1].clone());\n\t\t\t\t\t}\n\t\t\t\t\t_ => {\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpub fn pop_from_array(&mut self, node:Box<StackNode>) {\n\t\tfor layer in self.stack.iter_mut().rev() {\n\t\t\tif layer.contains_key(node.args[0].operation.clone().as_str()) {\n\t\t\t\tmatch *layer.get(&*node.args[0].operation).unwrap().ntype.clone() {\n\t\t\t\t\tNodeType::Str(mut val) => {\n\t\t\t\t\t\tval.pop();\n\t\t\t\t\t\tlayer.get_mut(&*node.args[0].operation).unwrap().ntype = Box::new(NodeType::Str(val));\n\t\t\t\t\t}\n\t\t\t\t\tNodeType::Vector => {\n\t\t\t\t\t\tlayer.get_mut(&*node.args[0].operation).unwrap().args.pop();\n\t\t\t\t\t}\n\t\t\t\t\t_ => {\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpub fn get_len(&mut self, args_list:Box<Vec<Box<StackNode>>>) -> Box<NodeType> {\n\t\tmatch *args_list[0].ntype.clone() {\n\t\t\tNodeType::Str(val) => {\n\t\t\t\treturn Box::new(NodeType::Int(Box::new(val.len() as i128)));\n\t\t\t},\n\t\t\tNodeType::Vector => {\n\t\t\t\treturn Box::new(NodeType::Int(Box::new(args_list[0].args.len() as i128)));\n\t\t\t},\n\t\t\t_ => {\n\t\t\t\teprintln!(\"Invalid type\");\n\t\t\t}\n\t\t}\n\t\tBox::new(NodeType::None)\n\t}\n\n\tpub fn get_range(&mut self, args_list:Box<Vec<Box<StackNode>>>) -> Box<StackNode> {\n\t\tlet mut vector = StackNode {\n\t\t\toperation: Box::new(String::new()),\n\t\t\tntype: Box::new(NodeType::Vector),\n\t\t\targs: Box::new(vec![]),\n\t\t\tscope: Box::new(vec![]),\n\t\t};\n\t\tmatch *args_list[0].ntype.clone() {\n\t\t\tNodeType::Int(val1) => {\n\t\t\t\tmatch *args_list[1].ntype.clone() {\n\t\t\t\t\tNodeType::Int(val2) => {\n\t\t\t\t\t\tfor i in *val1..*val2 {\n\t\t\t\t\t\t\tvector.args.push(Box::new(StackNode {\n\t\t\t\t\t\t\t\toperation: Box::new(String::new()),\n\t\t\t\t\t\t\t\tntype: Box::new(NodeType::Int(Box::new(i))),\n\t\t\t\t\t\t\t\targs: Box::new(vec![]),\n\t\t\t\t\t\t\t\tscope: Box::new(vec![]),\n\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t_ => {\n\t\t\t\t\t\teprintln!(\"Invalid type\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t_ => {\n\t\t\t\teprintln!(\"Invalid type\");\n\t\t\t}\n\t\t}\n\t\tBox::new(vector)\n\t}\n\n\tpub fn vec_to_str(&mut self, vect:Box<StackNode>) -> String {\n\t\tlet mut return_string = String::new();\n\t\treturn_string += \"[\";\n\t\tfor node in vect.args.iter() {\n\t\t\tmatch *node.ntype.clone() {\n\t\t\t\tNodeType::Str(val) => {\n\t\t\t\t\treturn_string += &String::from(format!(\"{:?}\", val));\n\t\t\t\t},\n\t\t\t\tNodeType::Int(val) => {\n\t\t\t\t\treturn_string += &String::from(format!(\"{val}\"));\n\t\t\t\t},\n\t\t\t\tNodeType::Float(val) => {\n\t\t\t\t\treturn_string += &String::from(format!(\"{val}\"));\n\t\t\t\t},\n\t\t\t\tNodeType::Bool(val) => {\n\t\t\t\t\treturn_string += &String::from(format!(\"{val}\"));\n\t\t\t\t},\n\t\t\t\tNodeType::Vector => {\n\t\t\t\t\treturn_string += &self.vec_to_str(node.clone());\n\t\t\t\t},\n\t\t\t\t_ => todo!(),\n\t\t\t}\n\t\t\treturn_string += \", \";\n\t\t}\n\t\tif return_string.len() > 2 {\n\t\t\treturn_string.pop();\n\t\t\treturn_string.pop();\n\t\t}\n\t\treturn_string += \"]\";\n\t\treturn_string\n\t}\n\n\tpub fn import_module(&mut self, file:String) {\n\t\tlet path = PathBuf::from(self.file_path.clone());\n\t\tlet dir = path.parent().unwrap();\n\t\tlet contents = fs::read_to_string(dir.join(file.clone()))\n\t\t\t.expect(\"Invalid filepath\");\n\t\tself.stack.last_mut().unwrap().extend(tokenize(contents, file, self.cli_args.clone()).into_iter());\n\t\t//println!(\"{:?}\",self.stack)\n\t}\n\tpub fn reverse_list(&mut self, mut args_list:Box<Vec<Box<StackNode>>>) -> Box<StackNode> {\n\t\tmatch *args_list[0].ntype.clone() {\n\t\t\tNodeType::Str(val) =>{\n\t\t\t\t*args_list[0].ntype = NodeType::Str(Box::new(val.chars().rev().collect::<String>()));\n\t\t\t},\n\t\t\tNodeType::Vector => {\n\t\t\t\targs_list[0].args.reverse();\n\t\t\t}\n\t\t\t_ => {},\n\t\t}\n\t\targs_list[0].clone()\n\t}\n}\n"}, "projects\\Fulcrum\\root\\src\\parts\\parser.rs": "use std::{io::{stdin, self}};\n\nuse indexmap::IndexMap;\n\nuse super::{datastructures::{StackNode, NodeType}};\npub mod standard;\n\npub struct Parser {\n\tpub file_path:String,\n\tpub cli_args:Vec<String>,\n\tpub stack:Box<Vec<Box<IndexMap<String, Box<StackNode>>>>>\n}\n\nimpl Parser {\n\tpub fn parse_tree(&mut self, root:Box<StackNode>){\n\t\t//Variables\n\t\tlet mut user_ret = Box::new(StackNode::default());\n\t\tuser_ret.ntype = Box::new(NodeType::None);\n\t\tself.parse_node(&mut user_ret, &mut Box::new(true), root.clone());\n\t}\n\t//used in the function below them\n\t\tfn rec_get_ind(&mut self, indexes_vector:Vec<usize>, st_num:usize, ind_key:String, node_to_push: Box<StackNode>) {\n\t\t\t//println!(\"called3\");\n\t\t\tlet mut var = &mut *self.stack[st_num].get_mut(&ind_key).unwrap();\n\t\t\tfor ind in indexes_vector.iter().rev() {\n\t\t\t\tvar = &mut var.args[*ind];\n\t\t\t}\n\t\t\t*var = node_to_push.clone();\n\t\t}\n\n\t\tfn rec_get_var(&mut self, curr_node:StackNode, indexes_vector:&mut Vec<usize>) -> Box<String> {\n\t\t\tif *curr_node.ntype == NodeType::Variable {\n\t\t\t\treturn curr_node.operation.clone();\n\t\t\t}\n\t\t\telse if *curr_node.ntype == NodeType::Index{\n\t\t\t\tlet mut user_ret = Box::new(StackNode::default());\n\t\t\t\tuser_ret.ntype = Box::new(NodeType::None);\n\t\t\t\tlet args_list = self.parse_node_list(&mut user_ret, false, curr_node.args.clone(), false);\n\t\t\t\tmatch *args_list[0].ntype.clone() {\n\t\t\t\t\tNodeType::Str(_) => todo!(\"hashmap implementation\"),\n\t\t\t\t\tNodeType::Int(val) => {indexes_vector.push(*val as usize)},\n\t\t\t\t\tNodeType::Float(val) => {indexes_vector.push(*val as usize)},\n\t\t\t\t\tNodeType::Bool(val) => {indexes_vector.push(*val as usize)},\n\t\t\t\t\t_ => todo!(),\n\t\t\t\t}\n\t\t\t\treturn self.rec_get_var(*curr_node.args[1].clone(), indexes_vector);\n\t\t\t}\n\t\t\tBox::new(String::new())\n\t\t}\n\t// end of used in the function below them\n\tfn push_to_stack (&mut self, current_node:Box<StackNode>, node_to_push:Box<StackNode>) {\n\t\tif *current_node.ntype == NodeType::Index {\n\t\t\t// assign to index of variable\n\t\t\t//println!(\"called, {:?}, {:?}\", self.stack, (0..self.stack.len()).rev().collect::<Vec<usize>>());\n\t\t\tlet mut indexes_vector:Vec<usize> = vec![];\n\t\t\tlet ind_key = *self.rec_get_var(*current_node.clone(), &mut indexes_vector);\n\t\t\t// let mut stack_ref_counter = Rc::new(RefCell::new(stack));\n\t\t\t// let mut itter_stack = Rc::clone(&stack_ref_counter);\n\t\t\t// let mut stackb1 = Rc::clone(&itter_stack);\n\t\t\t// let mut stackb2 = Rc::clone(&stackb1);\n\t\t\tfor st_num in (0..self.stack.len()).rev() {\n\t\t\t\tif self.stack[st_num].contains_key(&ind_key.clone()) {\n\t\t\t\t\tlet mut user_ret = Box::new(StackNode::default());\n\t\t\t\t\tuser_ret.ntype = Box::new(NodeType::None);\n\t\t\t\t\t//let args_list = self.parse_node_list(&mut user_ret, false, current_node.args.clone(), false);\n\t\t\t\t\t//println!(\"called2\");\n\t\t\t\t\tself.rec_get_ind(indexes_vector, st_num, ind_key, node_to_push.clone());\n\t\t\t\t\t//println!(\"layer===={:?}\", layer);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tlet st_end:usize = self.stack.len()-1;\n\t\t\tfor layer in self.stack.iter_mut().rev() {\n\t\t\t\tif layer.contains_key(&*current_node.operation.clone()) {\n\t\t\t\t\t*layer.get_mut(&*current_node.operation).unwrap() = node_to_push.clone();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tself.stack[st_end].insert(*current_node.operation.clone(), node_to_push.clone());\n\t\t}\n\t}\n\t\n\tfn parse_node_list(&mut self, mut user_return:&mut Box<StackNode>, is_scope:bool, node_list:Box<Vec<Box<StackNode>>>, is_global:bool) -> Box<Vec<Box<StackNode>>> {\n\t\tlet mut ret_list:Box<Vec<Box<StackNode>>> = Box::new(vec![]);\n\t\t//boolean is passed in per layer of the stack to enable or disable execution based on\n\t\t//conditional statements\n\t\tlet mut executing:Box<bool> = Box::new(true);\n\t\t\n\t\tif is_scope {\n\t\t\tself.stack.push(Box::new(IndexMap::new()));\n\t\t\t// garbage_stack.push(Box::new(vec![]));\n\t\t}\n\t\tfor curr_node in node_list.iter() {\n\t\t\tif *user_return.ntype != NodeType::None {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlet new_node = self.parse_node(&mut user_return, &mut executing, Box::new(*curr_node.clone()));\n\t\t\tret_list.push(new_node);\n\t\t}\n\t\tif is_scope && !is_global {\n\t\t\t// for trash in garbage_stack.last().unwrap().iter() {\n\t\t\t// \tstack.last().unwrap().remove(&**trash);\n\t\t\t// }\n\t\t\tself.stack.pop();\n\t\t\t// garbage_stack.pop();\n\t\t}\n\t\tret_list\n\t}\n\t\n\tfn get_variable(&mut self, key:String) -> Box<StackNode> {\n\t\tfor layer in self.stack.iter().rev() {\n\t\t\tif layer.contains_key(&key) {\n\t\t\t\treturn layer.get(&key).unwrap().clone()\n\t\t\t}\n\t\t}\n\t\treturn Box::new(StackNode::default());\n\t}\n\t\n\tpub fn parse_node(&mut self, mut user_return: &mut Box<StackNode>, mut executing:&mut Box<bool>, node:Box<StackNode>) -> Box<StackNode>{\n\t\t//println!(\"\\n{:?}\", node);\n\t\tif !vec![NodeType::Condition, NodeType::Def].contains(&node.ntype) || (*node.ntype == NodeType::Condition && *node.operation == \"if\") {\n\t\t\t**executing = true;\n\t\t}\n\t\tlet mut args_list:Box<Vec<Box<StackNode>>> = Box::new(vec![]);\n\t\tlet mut ret_node:Box<StackNode> = Box::new(StackNode::default());\n\t\t*ret_node.ntype = NodeType::None;\n\t\tif **executing {\n\t\t\tif !vec![NodeType::Def, NodeType::Loop].contains(&*node.ntype.clone()) {\n\t\t\t\targs_list = self.parse_node_list(&mut user_return, false, node.args.clone(), false);\n\t\t\t}\n\t\t\tmatch *node.ntype {\n\t\t\t\tNodeType::Call => {\n\t\t\t\t\tmatch node.operation.as_str() {\n\t\t\t\t\t\t\"\" => {\n\t\t\t\t\t\t\tself.parse_node_list(&mut user_return, true, node.scope.clone(), true);\n\t\t\t\t\t\t\t//global scope\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\"import\" => {\n\t\t\t\t\t\t\tmatch &*args_list[0].ntype {\n\t\t\t\t\t\t\t\tNodeType::Str(val) => {\n\t\t\t\t\t\t\t\t\tself.import_module(*val.clone());\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t_ => {},\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\"print\" => {\n\t\t\t\t\t\t\tmatch &*args_list[0].ntype {\n\t\t\t\t\t\t\t\tNodeType::Str(val) => print!(\"{val}\"),\n\t\t\t\t\t\t\t\tNodeType::Int(val) => print!(\"{val}\"),\n\t\t\t\t\t\t\t\tNodeType::Float(val) => print!(\"{val}\"),\n\t\t\t\t\t\t\t\tNodeType::Bool(val) => print!(\"{val}\"),\n\t\t\t\t\t\t\t\tNodeType::Vector => {\n\t\t\t\t\t\t\t\t\tprint!(\"{}\", self.vec_to_str(args_list[0].clone()));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t_ => {},\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\"push\" => {\n\t\t\t\t\t\t\tself.push_to_array(node, args_list);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\"pop\" => {\n\t\t\t\t\t\t\tself.pop_from_array(node);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\"len\" => {\n\t\t\t\t\t\t\tret_node.ntype = self.get_len(args_list);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\"range\" => {\n\t\t\t\t\t\t\tret_node = self.get_range(args_list);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\"CLI\" => {\n\t\t\t\t\t\t\tmatch &*args_list[0].ntype {\n\t\t\t\t\t\t\t\tNodeType::Int(val) => {\n\t\t\t\t\t\t\t\t\tret_node.ntype = Box::new(NodeType::Str(Box::new(self.cli_args[**val as usize + 1].clone())))\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t_ => {},\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\"FFI\" => {\n\t\t\t\t\t\t\tret_node.ntype = self.foreign_function_interface(args_list);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\"split\" => {\n\t\t\t\t\t\t\tret_node = self.split(args_list);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\"rev\" => {\n\t\t\t\t\t\t\tret_node = self.reverse_list(args_list);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\"trim\" => {\n\t\t\t\t\t\t\tret_node.ntype = self.remove_ws(args_list);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\"replace\" => {\n\t\t\t\t\t\t\tret_node.ntype = self.replace(args_list);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\"cat\" => {\n\t\t\t\t\t\t\tret_node.ntype = self.cat(args_list);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//put the math and complex functions into std/standard.rs as functions\n\t\t\t\t\t\t\"add\" => {\n\t\t\t\t\t\t\tret_node.ntype = self.add(args_list[0].ntype.clone(), args_list[1].ntype.clone());\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\"sub\" => {\n\t\t\t\t\t\t\tret_node.ntype = self.sub(args_list[0].ntype.clone(), args_list[1].ntype.clone());\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\"mul\" => {\n\t\t\t\t\t\t\tret_node.ntype = self.mul(args_list[0].ntype.clone(), args_list[1].ntype.clone());\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\"div\" => {\n\t\t\t\t\t\t\tret_node.ntype = self.div(args_list[0].ntype.clone(), args_list[1].ntype.clone());\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\"and\" => {\n\t\t\t\t\t\t\tret_node.ntype = self.and(args_list[0].ntype.clone(), args_list[1].ntype.clone());\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\"or\" => {\n\t\t\t\t\t\t\tret_node.ntype = self.or(args_list[0].ntype.clone(), args_list[1].ntype.clone());\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\"N\" => {\n\t\t\t\t\t\t\t//NOT\n\t\t\t\t\t\t\tret_node.ntype = match *args_list[0].ntype.clone() {\n\t\t\t\t\t\t\t\tNodeType::Str(val) => if *val == \"\" {Box::new(NodeType::Bool(Box::new(true)))} else {Box::new(NodeType::Bool(Box::new(false)))},\n\t\t\t\t\t\t\t\tNodeType::Int(val) => Box::new(NodeType::Bool(Box::new(*val == 0))),\n\t\t\t\t\t\t\t\tNodeType::Float(val) => Box::new(NodeType::Bool(Box::new(*val == 0.0))),\n\t\t\t\t\t\t\t\tNodeType::Bool(val) => Box::new(NodeType::Bool(Box::new(!*val))),\n\t\t\t\t\t\t\t\t_ => {Box::new(NodeType::Bool(Box::new(true)))},\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\"E\" => {\n\t\t\t\t\t\t\t//EQUAL\n\t\t\t\t\t\t\tret_node.ntype = self.equal(args_list[0].clone(), args_list[1].clone());\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\"NE\" => {\n\t\t\t\t\t\t\t//NOT EQUAL\n\t\t\t\t\t\t\tret_node.ntype = self.notequal(args_list[0].clone(), args_list[1].clone());\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\"G\" => {\n\t\t\t\t\t\t\t//GREATER\n\t\t\t\t\t\t\tret_node.ntype = self.greater(args_list[0].ntype.clone(), args_list[1].ntype.clone());\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\"L\" => {\n\t\t\t\t\t\t\t//LESS\n\t\t\t\t\t\t\tret_node.ntype = self.less(args_list[0].ntype.clone(), args_list[1].ntype.clone());\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\"GE\" => {\n\t\t\t\t\t\t\t//GREATER OR EQUAL\n\t\t\t\t\t\t\tret_node.ntype = self.greaterequal(args_list[0].ntype.clone(), args_list[1].ntype.clone());\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\"LE\" => {\n\t\t\t\t\t\t\t//LESS OR EQUAL\n\t\t\t\t\t\t\tret_node.ntype = self.lessequal(args_list[0].ntype.clone(), args_list[1].ntype.clone());\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\"read\" => {\n\t\t\t\t\t\t\t//read from files and return contents\n\t\t\t\t\t\t\t//eg: read(\"folder/filepath.txt\");\n\t\t\t\t\t\t\tret_node.ntype = self.read(args_list[0].ntype.clone());\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\"write\" => {\n\t\t\t\t\t\t\t//write to files\n\t\t\t\t\t\t\t//arg1 is the file name, arg3 is writemode (append or truncate or nothing for default(the default is truncate))\n\t\t\t\t\t\t\t//arg2 is the content to write to the file.\n\t\t\t\t\t\t\t//eg: write(\"folder/filepath.txt\", \"FulcrumRS is a cool language.\", \"a\"|\"t\"|None);\n\t\t\t\t\t\t\tret_node.ntype = self.filewrite(args_list[0].ntype.clone(), args_list[1].ntype.clone(), args_list[2].ntype.clone());\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\"input\" => {\n\t\t\t\t\t\t\tlet mut ret_val = String::new();\n\t\t\t\t\t\t\tio::Write:: flush(&mut io::stdout()).expect(\"flush failed!\");\n\t\t\t\t\t\t\tstdin().read_line(&mut ret_val).unwrap();\n\t\t\t\t\t\t\tfn remove_suffix<'a>(s: &'a str, p: &str) -> &'a str {\n\t\t\t\t\t\t\t\tif s.ends_with(p) {\n\t\t\t\t\t\t\t\t\t&s[..s.len() - p.len()]\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ts\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t*ret_node.ntype = NodeType::Str(Box::new(String::from(String::from(remove_suffix( &remove_suffix(&ret_val, \"\\n\"), \"\\r\")))))\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\"INT\" => {\n\t\t\t\t\t\t\tmatch &*args_list[0].ntype {\n\t\t\t\t\t\t\t\tNodeType::Str(val) => {\n\t\t\t\t\t\t\t\t\t//println!(\"val:{val};\");\n\t\t\t\t\t\t\t\t\t*ret_node.ntype = NodeType::Int(Box::new(val.parse::<i128>().unwrap()))\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tNodeType::Int(val) => *ret_node.ntype = NodeType::Int(Box::new(**val)),\n\t\t\t\t\t\t\t\tNodeType::Float(val) => *ret_node.ntype = NodeType::Int(Box::new(**val as i128)),\n\t\t\t\t\t\t\t\tNodeType::Bool(val) => *ret_node.ntype = NodeType::Int(if **val {Box::new(1)} else {Box::new(0)}),\n\t\t\t\t\t\t\t\t_ => {},\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\"FLOAT\" => {\n\t\t\t\t\t\t\tmatch &*args_list[0].ntype {\n\t\t\t\t\t\t\t\tNodeType::Str(val) => *ret_node.ntype = NodeType::Float(Box::new(val.parse::<f64>().unwrap())),\n\t\t\t\t\t\t\t\tNodeType::Int(val) => *ret_node.ntype = NodeType::Float(Box::new(**val as f64)),\n\t\t\t\t\t\t\t\tNodeType::Float(val) => *ret_node.ntype = NodeType::Float(Box::new(**val)),\n\t\t\t\t\t\t\t\tNodeType::Bool(val) => *ret_node.ntype = NodeType::Float(if **val {Box::new(1.0)} else {Box::new(0.0)}),\n\t\t\t\t\t\t\t\t_ => {},\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\"STR\" => {\n\t\t\t\t\t\t\tmatch &*args_list[0].ntype.clone() {\n\t\t\t\t\t\t\t\tNodeType::Str(val) => *ret_node.ntype = NodeType::Str(Box::new(String::from(format!(\"{val}\")))),\n\t\t\t\t\t\t\t\tNodeType::Int(val) => *ret_node.ntype = NodeType::Str(Box::new(String::from(format!(\"{val}\")))),\n\t\t\t\t\t\t\t\tNodeType::Float(val) => *ret_node.ntype = NodeType::Str(Box::new(String::from(format!(\"{val}\")))),\n\t\t\t\t\t\t\t\tNodeType::Bool(val) => *ret_node.ntype = NodeType::Str(Box::new(String::from(format!(\"{val}\")))),\n\t\t\t\t\t\t\t\tNodeType::Vector => {\n\t\t\t\t\t\t\t\t\t*ret_node.ntype = NodeType::Str(Box::new(self.vec_to_str(args_list[0].clone())));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t_ => {},\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\"BOOL\" => {\n\t\t\t\t\t\t\tmatch &*args_list[0].ntype.clone() {\n\t\t\t\t\t\t\t\tNodeType::Str(val) => *ret_node.ntype = NodeType::Bool(if vec![\"true\",\"t\",\"yes\"].contains(&&*val.as_str().to_lowercase()) {Box::new(true)} else {Box::new(false)}),\n\t\t\t\t\t\t\t\tNodeType::Int(val) => *ret_node.ntype = NodeType::Bool(if **val > 0 {Box::new(true)} else {Box::new(false)}),\n\t\t\t\t\t\t\t\tNodeType::Float(val) => *ret_node.ntype = NodeType::Bool(if **val > 0.0 {Box::new(true)} else {Box::new(false)}),\n\t\t\t\t\t\t\t\tNodeType::Bool(val) => *ret_node.ntype = NodeType::Bool(if **val {Box::new(true)} else {Box::new(false)}),\n\t\t\t\t\t\t\t\t_ => {},\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_ => {\n\t\t\t\t\t\t\tlet mut user_func = self.get_variable(*node.operation.clone());\n\t\t\t\t\t\t\tself.stack.push(Box::new(IndexMap::new()));\n\t\t\t\t\t\t\tfor (an, arg) in args_list.iter().enumerate() {\n\t\t\t\t\t\t\t\t//println!(\"{}\", node.operation.clone());\n\t\t\t\t\t\t\t\tlet name = user_func.args[an].operation.clone();\n\t\t\t\t\t\t\t\tuser_func.args[an] = arg.clone();\n\t\t\t\t\t\t\t\tuser_func.args[an].operation = name;\n\t\t\t\t\t\t\t\tlet st_end = self.stack.len() -1;\n\t\t\t\t\t\t\t\tself.stack[st_end].insert(*user_func.args[an].operation.clone(), arg.clone());\n\t\t\t\t\t\t\t\t//push_to_stack(user_func.args[an].clone(), arg.clone(), &mut stack, &mut garbage_stack);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet mut passable_return = Box::new(StackNode::default());\n\t\t\t\t\t\t\tpassable_return.ntype = Box::new(NodeType::None);\n\t\t\t\t\t\t\tself.parse_node_list(&mut passable_return, true, user_func.scope, false);\n\t\t\t\t\t\t\t// for trash in garbage_stack.last().unwrap().iter() {\n\t\t\t\t\t\t\t// \tstack.remove(&**trash);\n\t\t\t\t\t\t\t// }\n\t\t\t\t\t\t\tself.stack.pop();\n\t\t\t\t\t\t\treturn passable_return;\n\t\t\t\t\t\t} \n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tNodeType::Def => {\n\t\t\t\t\tself.push_to_stack(node.clone(), node.clone());\n\t\t\t\t\t*ret_node = StackNode { operation: node.operation, ntype: node.ntype, args: node.args, scope: node.scope };\n\t\t\t\t},\n\t\t\t\tNodeType::Assign => {\n\t\t\t\t\t//println!(\"LHS +++ {:?}\", node.args[0]);\n\t\t\t\t\tself.push_to_stack(node.args[0].clone(), args_list[1].clone());\n\t\t\t\t},\n\t\t\t\tNodeType::Variable => {\n\t\t\t\t\tret_node = self.get_variable(*node.operation).clone();\n\t\t\t\t},\n\t\t\t\tNodeType::Return => {\n\t\t\t\t\t//*user_return.operation = String::from(\"return\");\n\t\t\t\t\tif args_list.len() > 0 {\n\t\t\t\t\t\t*user_return = args_list[0].clone();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t*user_return.ntype = NodeType::Return;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t},\n\t\t\t\tNodeType::Condition => {\n\t\t\t\t\tmatch node.operation.as_str() {\n\t\t\t\t\t\t\"if\" => {\n\t\t\t\t\t\t\tmatch &*args_list[0].ntype {\n\t\t\t\t\t\t\t\tNodeType::Str(val) => {\n\t\t\t\t\t\t\t\t\tif **val != \"\" {\n\t\t\t\t\t\t\t\t\t\tself.parse_node_list(&mut user_return, true, node.scope, false);\n\t\t\t\t\t\t\t\t\t\t**executing = false;\n\t\t\t\t\t\t\t\t\t\t*ret_node.ntype = NodeType::Bool(Box::new(true));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tNodeType::Int(val) => {\n\t\t\t\t\t\t\t\t\tif **val > 0 {\n\t\t\t\t\t\t\t\t\t\tself.parse_node_list(&mut user_return, true, node.scope, false);\n\t\t\t\t\t\t\t\t\t\t**executing = false;\n\t\t\t\t\t\t\t\t\t\t*ret_node.ntype = NodeType::Bool(Box::new(true));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tNodeType::Float(val) => {\n\t\t\t\t\t\t\t\t\tif **val > 0.0 {\n\t\t\t\t\t\t\t\t\t\tself.parse_node_list(&mut user_return, true, node.scope, false);\n\t\t\t\t\t\t\t\t\t\t**executing = false;\n\t\t\t\t\t\t\t\t\t\t*ret_node.ntype = NodeType::Bool(Box::new(true));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tNodeType::Bool(val) => {\n\t\t\t\t\t\t\t\t\tif **val {\n\t\t\t\t\t\t\t\t\t\tself.parse_node_list(&mut user_return, true, node.scope, false);\n\t\t\t\t\t\t\t\t\t\t**executing = false;\n\t\t\t\t\t\t\t\t\t\t*ret_node.ntype = NodeType::Bool(Box::new(true));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t_ => {},\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t*ret_node.ntype = NodeType::Bool(Box::new(false));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\"elif\" => {\n\t\t\t\t\t\t\t//println!(\"{:?}\", node);\n\t\t\t\t\t\t\tmatch &*args_list[0].ntype {\n\t\t\t\t\t\t\t\tNodeType::Str(val) => {\n\t\t\t\t\t\t\t\t\tif **val != \"\" {\n\t\t\t\t\t\t\t\t\t\tself.parse_node_list(&mut user_return, true, node.scope, false);\n\t\t\t\t\t\t\t\t\t\t**executing = false;\n\t\t\t\t\t\t\t\t\t\t*ret_node.ntype = NodeType::Bool(Box::new(true));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tNodeType::Int(val) => {\n\t\t\t\t\t\t\t\t\tif **val > 0 {\n\t\t\t\t\t\t\t\t\t\tself.parse_node_list(&mut user_return, true, node.scope, false);\n\t\t\t\t\t\t\t\t\t\t**executing = false;\n\t\t\t\t\t\t\t\t\t\t*ret_node.ntype = NodeType::Bool(Box::new(true));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tNodeType::Float(val) => {\n\t\t\t\t\t\t\t\t\tif **val > 0.0 {\n\t\t\t\t\t\t\t\t\t\tself.parse_node_list(&mut user_return, true, node.scope, false);\n\t\t\t\t\t\t\t\t\t\t**executing = false;\n\t\t\t\t\t\t\t\t\t\t*ret_node.ntype = NodeType::Bool(Box::new(true));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tNodeType::Bool(val) => {\n\t\t\t\t\t\t\t\t\tif **val {\n\t\t\t\t\t\t\t\t\t\tself.parse_node_list(&mut user_return, true, node.scope, false);\n\t\t\t\t\t\t\t\t\t\t**executing = false;\n\t\t\t\t\t\t\t\t\t\t*ret_node.ntype = NodeType::Bool(Box::new(true));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t_ => {},\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t*ret_node.ntype = NodeType::Bool(Box::new(false))\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\"else\" => {\n\t\t\t\t\t\t\tself.parse_node_list(&mut user_return, true, node.scope, false);\n\t\t\t\t\t\t\t*ret_node.ntype = NodeType::Bool(Box::new(false))\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_ => {\n\t\t\t\t\t\t\t*ret_node.ntype = NodeType::None\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tNodeType::Vector => {\n\t\t\t\t\t*ret_node.ntype = NodeType::Vector;\n\t\t\t\t\tret_node.args = args_list;\n\t\t\t\t},\n\t\t\t\tNodeType::Index => {\n\t\t\t\t\t//println!(\"{:?}\", stack);\n\t\t\t\t\tlet arg1 = *args_list[1].ntype.clone();\n\t\t\t\t\tlet arg2 = *args_list[0].ntype.clone();\n\t\t\t\t\tmatch arg1 {\n\t\t\t\t\t\tNodeType::Str(val) => {\n\t\t\t\t\t\t\tmatch arg2 {\n\t\t\t\t\t\t\t\tNodeType::Str(val2) => {\n\t\t\t\t\t\t\t\t\t*ret_node.ntype = NodeType::Str(Box::new(String::from(val.chars().collect::<Vec<char>>()[val2.parse::<usize>().expect(\"The provided string caused an invalid cast to integer.\")])));\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tNodeType::Int(val2) => {\n\t\t\t\t\t\t\t\t\t*ret_node.ntype = NodeType::Str(Box::new(String::from(val.chars().collect::<Vec<char>>()[*val2 as usize])));\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tNodeType::Float(val2) => {\n\t\t\t\t\t\t\t\t\t*ret_node.ntype = NodeType::Str(Box::new(String::from(val.chars().collect::<Vec<char>>()[*val2 as usize])));\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tNodeType::Bool(val2) => {\n\t\t\t\t\t\t\t\t\t*ret_node.ntype = NodeType::Str(Box::new(String::from(val.chars().collect::<Vec<char>>()[*val2 as usize])));\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t_ => {},\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_ => {\n\t\t\t\t\t\t\tmatch arg2 {\n\t\t\t\t\t\t\t\tNodeType::Str(val) => {\n\t\t\t\t\t\t\t\t\treturn self.parse_node(&mut user_return, &mut executing, args_list[1].args[val.parse::<usize>().expect(\"The provided string caused an invalid cast to integer.\")].clone())\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tNodeType::Int(val) => {\n\t\t\t\t\t\t\t\t\treturn self.parse_node(&mut user_return, &mut executing, args_list[1].args[*val as usize].clone())\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tNodeType::Float(val) => {\n\t\t\t\t\t\t\t\t\treturn self.parse_node(&mut user_return, &mut executing, args_list[1].args[*val as usize].clone())\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tNodeType::Bool(val) => {\n\t\t\t\t\t\t\t\t\treturn self.parse_node(&mut user_return, &mut executing, args_list[1].args[*val as usize].clone())\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t_ => {},\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tNodeType::Str(val) => *ret_node.ntype = NodeType::Str(val),\n\t\t\t\tNodeType::Int(val) => *ret_node.ntype = NodeType::Int(val),\n\t\t\t\tNodeType::Float(val) => *ret_node.ntype = NodeType::Float(val),\n\t\t\t\tNodeType::Bool(val) => *ret_node.ntype = NodeType::Bool(val),\n\t\t\t\tNodeType::None => todo!(),\n\t\t\t\tNodeType::Loop => {\n\t\t\t\t\tmatch node.operation.as_str() {\n\t\t\t\t\t\t\"for\" => {\n\t\t\t\t\t\t\tself.stack.push(Box::new(IndexMap::new()));\n\t\t\t\t\t\t\tlet alist = self.parse_node_list(&mut user_return, false, node.args.clone(), false);\n\t\t\t\t\t\t\tmatch *alist[1].ntype.clone() {\n\t\t\t\t\t\t\t\tNodeType::Str(val) => {\n\t\t\t\t\t\t\t\t\tfor value in val.chars() {\n\t\t\t\t\t\t\t\t\t\tlet mut val_for_stack = Box::new(StackNode::default());\n\t\t\t\t\t\t\t\t\t\t*val_for_stack.ntype = NodeType::Str(Box::new(String::from(value)));\n\t\t\t\t\t\t\t\t\t\tself.push_to_stack(node.args[0].clone(), val_for_stack.clone());\n\t\t\t\t\t\t\t\t\t\tself.parse_node_list(&mut user_return, true, node.scope.clone(), false);\n\t\t\t\t\t\t\t\t\t\tif *user_return.ntype == NodeType::Break {\n\t\t\t\t\t\t\t\t\t\t\t*user_return.ntype = NodeType::None;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif *user_return.ntype != NodeType::None {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tNodeType::Int(val) => {\n\t\t\t\t\t\t\t\t\tfor value in 0..*val {\n\t\t\t\t\t\t\t\t\t\tlet mut val_for_stack = Box::new(StackNode::default());\n\t\t\t\t\t\t\t\t\t\t*val_for_stack.ntype = NodeType::Int(Box::new(value));\n\t\t\t\t\t\t\t\t\t\tself.push_to_stack(node.args[0].clone(), val_for_stack.clone());\n\t\t\t\t\t\t\t\t\t\tself.parse_node_list(&mut user_return, true, node.scope.clone(), false);\n\t\t\t\t\t\t\t\t\t\tif *user_return.ntype == NodeType::Break {\n\t\t\t\t\t\t\t\t\t\t\t*user_return.ntype = NodeType::None;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif *user_return.ntype != NodeType::None {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tNodeType::Vector => {\n\t\t\t\t\t\t\t\t\tfor value in alist[1].args.iter() {\n\t\t\t\t\t\t\t\t\t\tself.push_to_stack(node.args[0].clone(), value.clone());\n\t\t\t\t\t\t\t\t\t\tself.parse_node_list(&mut user_return, true, node.scope.clone(), false);\n\t\t\t\t\t\t\t\t\t\tif *user_return.ntype == NodeType::Break {\n\t\t\t\t\t\t\t\t\t\t\t*user_return.ntype = NodeType::None;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif *user_return.ntype != NodeType::None {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t_ => {\n\t\t\t\t\t\t\t\t\tprintln!(\"ERROR<loop::for>(make an issue on the git repo with this message and your source code): {:?}\", self.stack);\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tself.stack.pop();\n\t\t\t\t\t\t\t//**executing = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\"while\" => {\n\t\t\t\t\t\t\tloop {\n\t\t\t\t\t\t\t\tlet alist = self.parse_node_list(&mut user_return, false, node.args.clone(), false);\n\t\t\t\t\t\t\t\tmatch *alist[0].ntype.clone() {\n\t\t\t\t\t\t\t\t\tNodeType::Bool(val) => {\n\t\t\t\t\t\t\t\t\t\tif *val {\n\t\t\t\t\t\t\t\t\t\t\tself.parse_node_list(&mut user_return, true, node.scope.clone(), false);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t_ => {\n\t\t\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif *user_return.ntype == NodeType::Break {\n\t\t\t\t\t\t\t\t\t*user_return.ntype = NodeType::None;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif *user_return.ntype != NodeType::None {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//**executing = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\"loop\" => {\n\t\t\t\t\t\t\tloop {\n\t\t\t\t\t\t\t\tself.parse_node_list(&mut user_return, true, node.scope.clone(), false);\n\t\t\t\t\t\t\t\tif *user_return.ntype == NodeType::Break {\n\t\t\t\t\t\t\t\t\t*user_return.ntype = NodeType::None;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif *user_return.ntype != NodeType::None {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//**executing = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_ => {\n\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tNodeType::Operator => {\n\t\t\t\t\tmatch node.operation.as_str() {\n\t\t\t\t\t\t\"contains\" => {\n\t\t\t\t\t\t\tret_node.ntype = self.contains_operator(&mut args_list[0].clone(), args_list[1].clone());\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\"in\" => {\n\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_ => {\n\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tNodeType::Break => {\n\t\t\t\t\t*user_return.ntype = NodeType::Break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tret_node\n\t}\n}", "projects\\Fulcrum\\root\\src\\parts\\tcdefinitions": {"projects\\Fulcrum\\root\\src\\parts\\tcdefinitions\\definitions.rs": "use crate::parts::datastructures::{StackNode, NodeType, Token};\n\npub fn func_call(name:String, stack_buffer:&mut Vec<(Box<StackNode>, Box<bool>)>) {\n\tstack_buffer.push((Box::new(StackNode {\n\t\toperation: Box::new(name),\n\t\tntype: Box::new(NodeType::Call),\n\t\targs: Box::new(vec![]),\n\t\tscope: Box::new(vec![]),\n\t}), Box::new(true)));\n}\n\npub fn func_def(name:String, stack_buffer:&mut Vec<(Box<StackNode>, Box<bool>)>) {\n\tstack_buffer.push((Box::new(StackNode {\n\t\toperation: Box::new(name),\n\t\tntype: Box::new(NodeType::Def),\n\t\targs: Box::new(vec![]),\n\t\tscope: Box::new(vec![]),\n\t}), Box::new(true)));\n}\n\npub fn condition_if(stack_buffer:&mut Vec<(Box<StackNode>, Box<bool>)>) {\n\tstack_buffer.push((Box::new(StackNode {\n\t\toperation: Box::new(String::from(\"if\")),\n\t\tntype: Box::new(NodeType::Condition),\n\t\targs: Box::new(vec![]),\n\t\tscope: Box::new(vec![]),\n\t}), Box::new(true)));\n}\n\npub fn condition_elif(stack_buffer:&mut Vec<(Box<StackNode>, Box<bool>)>) {\n\tstack_buffer.push((Box::new(StackNode {\n\t\toperation: Box::new(String::from(\"elif\")),\n\t\tntype: Box::new(NodeType::Condition),\n\t\targs: Box::new(vec![]),\n\t\tscope: Box::new(vec![]),\n\t}), Box::new(true)));\n}\n\npub fn condition_else(stack_buffer:&mut Vec<(Box<StackNode>, Box<bool>)>) {\n\tstack_buffer.push((Box::new(StackNode {\n\t\toperation: Box::new(String::from(\"else\")),\n\t\tntype: Box::new(NodeType::Condition),\n\t\targs: Box::new(vec![]),\n\t\tscope: Box::new(vec![]),\n\t}), Box::new(true)));\n}\n\npub fn loop_for(stack_buffer:&mut Vec<(Box<StackNode>, Box<bool>)>) {\n\tstack_buffer.push((Box::new(StackNode {\n\t\toperation: Box::new(String::from(\"for\")),\n\t\tntype: Box::new(NodeType::Loop),\n\t\targs: Box::new(vec![]),\n\t\tscope: Box::new(vec![]),\n\t}), Box::new(true)));\n}\n\npub fn loop_while(stack_buffer:&mut Vec<(Box<StackNode>, Box<bool>)>) {\n\tstack_buffer.push((Box::new(StackNode {\n\t\toperation: Box::new(String::from(\"while\")),\n\t\tntype: Box::new(NodeType::Loop),\n\t\targs: Box::new(vec![]),\n\t\tscope: Box::new(vec![]),\n\t}), Box::new(true)));\n}\n\npub fn loop_loop(stack_buffer:&mut Vec<(Box<StackNode>, Box<bool>)>) {\n\tstack_buffer.push((Box::new(StackNode {\n\t\toperation: Box::new(String::from(\"loop\")),\n\t\tntype: Box::new(NodeType::Loop),\n\t\targs: Box::new(vec![]),\n\t\tscope: Box::new(vec![]),\n\t}), Box::new(true)));\n}\n\nfn ends(stack_buffer:&mut Vec<(Box<StackNode>, Box<bool>)>) {\n\tlet last_sb = stack_buffer.len() - 1;\n\tlet last_node = *stack_buffer[last_sb].0.clone();\n\tstack_buffer.pop();\n\tlet last_sb = stack_buffer.len() - 1;\n\t// let last_inner = stack_buffer[last_sb].0.args.len();\n\t// if if last_inner >= 1 {*stack_buffer[last_sb].0.scope[last_inner as usize-1].ntype.clone()} else {NodeType::None} == NodeType::Assign {\n\t\t\n\t// \tstack_buffer[last_sb].0.args[last_inner].args.push(Box::new(last_node));\n\t// }\n\tif *stack_buffer[last_sb].1 {\n\t\tstack_buffer[last_sb].0.args.push(Box::new(last_node));\n\t}\n\telse {\n\t\tstack_buffer[last_sb].0.scope.push(Box::new(last_node));\n\t}\n}\n\npub fn line_end(mut stack_buffer:&mut Vec<(Box<StackNode>, Box<bool>)>) {\n\tif vec![NodeType::Assign, NodeType::Return].contains(&stack_buffer.last().unwrap().0.ntype) {\n\t\tends(&mut stack_buffer);\n\t}\n}\n\npub fn statement_end(mut stack_buffer:&mut Vec<(Box<StackNode>, Box<bool>)>) {\n\tif *stack_buffer.last().unwrap().0.ntype != NodeType::Def {\n\t\tends(&mut stack_buffer);\n\t}\n}\n\npub fn scope_end(mut stack_buffer:&mut Vec<(Box<StackNode>, Box<bool>)>) {\n\tends(&mut stack_buffer);\n}\npub fn vec_end(mut stack_buffer:&mut Vec<(Box<StackNode>, Box<bool>)>) {\n\tends(&mut stack_buffer);\n}\n\npub fn scope_start(stack_buffer:&mut Vec<(Box<StackNode>, Box<bool>)>) {\n\tlet last_sb = stack_buffer.len() - 1;\n\tstack_buffer[last_sb].1 = Box::new(false);\n}\n\npub fn literal(token:Token, stack_buffer:&mut Vec<(Box<StackNode>, Box<bool>)>) {\n\tlet last_sb = stack_buffer.len() - 1;\n\tif *stack_buffer[last_sb].1 {\n\t\tmatch token {\n\t\t\tToken::StringLit(val) => stack_buffer[last_sb].0.args.push(Box::new(StackNode {\n\t\t\t\toperation: Box::new(String::new()),\n\t\t\t\tntype: Box::new(NodeType::Str(val)),\n\t\t\t\targs: Box::new(vec![]),\n\t\t\t\tscope: Box::new(vec![]),\n\t\t\t})),\n\t\t\tToken::IntLit(val) => stack_buffer[last_sb].0.args.push(Box::new(StackNode {\n\t\t\t\toperation: Box::new(String::new()),\n\t\t\t\tntype: Box::new(NodeType::Int(val)),\n\t\t\t\targs: Box::new(vec![]),\n\t\t\t\tscope: Box::new(vec![]),\n\t\t\t})),\n\t\t\tToken::FloatLit(val) => stack_buffer[last_sb].0.args.push(Box::new(StackNode {\n\t\t\t\toperation: Box::new(String::new()),\n\t\t\t\tntype: Box::new(NodeType::Float(val)),\n\t\t\t\targs: Box::new(vec![]),\n\t\t\t\tscope: Box::new(vec![]),\n\t\t\t})),\n\t\t\tToken::BooleanLit(val) => stack_buffer[last_sb].0.args.push(Box::new(StackNode {\n\t\t\t\toperation: Box::new(String::new()),\n\t\t\t\tntype: Box::new(NodeType::Bool(val)),\n\t\t\t\targs: Box::new(vec![]),\n\t\t\t\tscope: Box::new(vec![]),\n\t\t\t})),\n\t\t\t_ => {},\n\t\t}\n\t}\n\telse {\n\t\tmatch token {\n\t\t\tToken::StringLit(val) => stack_buffer[last_sb].0.scope.push(Box::new(StackNode {\n\t\t\t\toperation: Box::new(String::new()),\n\t\t\t\tntype: Box::new(NodeType::Str(val)),\n\t\t\t\targs: Box::new(vec![]),\n\t\t\t\tscope: Box::new(vec![]),\n\t\t\t})),\n\t\t\tToken::IntLit(val) => stack_buffer[last_sb].0.scope.push(Box::new(StackNode {\n\t\t\t\toperation: Box::new(String::new()),\n\t\t\t\tntype: Box::new(NodeType::Int(val)),\n\t\t\t\targs: Box::new(vec![]),\n\t\t\t\tscope: Box::new(vec![]),\n\t\t\t})),\n\t\t\tToken::FloatLit(val) => stack_buffer[last_sb].0.scope.push(Box::new(StackNode {\n\t\t\t\toperation: Box::new(String::new()),\n\t\t\t\tntype: Box::new(NodeType::Float(val)),\n\t\t\t\targs: Box::new(vec![]),\n\t\t\t\tscope: Box::new(vec![]),\n\t\t\t})),\n\t\t\tToken::BooleanLit(val) => stack_buffer[last_sb].0.scope.push(Box::new(StackNode {\n\t\t\t\toperation: Box::new(String::new()),\n\t\t\t\tntype: Box::new(NodeType::Bool(val)),\n\t\t\t\targs: Box::new(vec![]),\n\t\t\t\tscope: Box::new(vec![]),\n\t\t\t})),\n\t\t\t_ => {},\n\t\t}\n\t}\n}\n\npub fn variable(name:String, stack_buffer:&mut Vec<(Box<StackNode>, Box<bool>)>) {\n\tlet last_sb = stack_buffer.len() - 1;\n\tif *stack_buffer[last_sb].1 {\n\t\tstack_buffer[last_sb].0.args.push(Box::new(StackNode {\n\t\t\toperation: Box::new(name),\n\t\t\tntype: Box::new(NodeType::Variable),\n\t\t\targs: Box::new(vec![]),\n\t\t\tscope: Box::new(vec![]),\n\t\t}));\n\t}\n\telse {\n\t\tstack_buffer[last_sb].0.scope.push(Box::new(StackNode {\n\t\t\toperation: Box::new(name),\n\t\t\tntype: Box::new(NodeType::Variable),\n\t\t\targs: Box::new(vec![]),\n\t\t\tscope: Box::new(vec![]),\n\t\t}));\n\t}\n}\n\npub fn assign(stack_buffer:&mut Vec<(Box<StackNode>, Box<bool>)>) {\n\t\n\tlet last_sb = stack_buffer.len() - 1;\n\tlet last_in_last_children = stack_buffer[last_sb].0.scope.last().unwrap().clone();\n\tstack_buffer[last_sb].0.scope.pop();\n\tstack_buffer.push((Box::new(StackNode {\n\t\toperation: Box::new(String::new()),\n\t\tntype: Box::new(NodeType::Assign),\n\t\targs: Box::new(vec![last_in_last_children]),\n\t\tscope: Box::new(vec![]),\n\t}), Box::new(true)));\n}\n\npub fn in_operator(stack_buffer:&mut Vec<(Box<StackNode>, Box<bool>)>) {\n\tlet last_sb = stack_buffer.len() - 1;\n\tif *stack_buffer[last_sb].0.ntype == NodeType::Loop && *stack_buffer[last_sb].0.operation == \"for\" {\n\t\t// stack_buffer.push((Box::new(StackNode {\n\t\t// \toperation: Box::new(String::from(\"in\")),\n\t\t// \tntype: Box::new(NodeType::Operator),\n\t\t// \targs: Box::new(vec![last_in_last_children]),\n\t\t// \tscope: Box::new(vec![]),\n\t\t// }), Box::new(false)));\n\t}\n\telse {\n\t\tlet last_in_last_children = stack_buffer[last_sb].0.args.last().unwrap().clone();\n\t\tstack_buffer[last_sb].0.args.pop();\n\t\tstack_buffer.push((Box::new(StackNode {\n\t\t\toperation: Box::new(String::from(\"contains\")),\n\t\t\tntype: Box::new(NodeType::Operator),\n\t\t\targs: Box::new(vec![last_in_last_children]),\n\t\t\tscope: Box::new(vec![]),\n\t\t}), Box::new(true)));\n\t}\n}\n\npub fn return_val(stack_buffer:&mut Box<Vec<(Box<StackNode>, Box<bool>)>>) {\n\tstack_buffer.push((Box::new(StackNode {\n\t\toperation: Box::new(String::new()),\n\t\tntype: Box::new(NodeType::Return),\n\t\targs: Box::new(vec![]),\n\t\tscope: Box::new(vec![]),\n\t}), Box::new(true)));\n}\n\npub fn vector(stack_buffer:&mut Box<Vec<(Box<StackNode>, Box<bool>)>>) {\n\tstack_buffer.push((Box::new(StackNode {\n\t\toperation: Box::new(String::new()),\n\t\tntype: Box::new(NodeType::Vector),//(Box::new(vec![])),\n\t\targs: Box::new(vec![]),\n\t\tscope: Box::new(vec![]),\n\t}), Box::new(true)));\n}\n\npub fn index(stack_buffer:&mut Box<Vec<(Box<StackNode>, Box<bool>)>>) {\n\tstack_buffer.push((Box::new(StackNode {\n\t\toperation: Box::new(String::new()),\n\t\tntype: Box::new(NodeType::Index),\n\t\targs: Box::new(vec![]),\n\t\tscope: Box::new(vec![]),\n\t}), Box::new(true)));\n}\n\npub fn end_index(stack_buffer:&mut Box<Vec<(Box<StackNode>, Box<bool>)>>) {\n\tlet last_sb = stack_buffer.len() - 1;\n\tlet mut last_node = *stack_buffer[last_sb].0.clone();\n\tstack_buffer.pop();\n\tlet last_sb = stack_buffer.len() - 1;\n\tif *stack_buffer[last_sb].1 {\n\t\tlet last_in_last_children = stack_buffer[last_sb].0.args.last().unwrap().clone();\n\t\tlast_node.args.push(last_in_last_children);\n\t\tstack_buffer[last_sb].0.args.pop();\n\t\tstack_buffer[last_sb].0.args.push(Box::new(last_node));\n\t}\n\telse {\n\t\tlet last_in_last_children = stack_buffer[last_sb].0.scope.last().unwrap().clone();\n\t\tlast_node.args.push(last_in_last_children);\n\t\tstack_buffer[last_sb].0.scope.pop();\n\t\tstack_buffer[last_sb].0.scope.push(Box::new(last_node));\n\t}\n}\n\npub fn break_keyword(stack_buffer:&mut Box<Vec<(Box<StackNode>, Box<bool>)>>) {\n\tlet sb_len = stack_buffer.len()-1;\n\tstack_buffer[sb_len].0.scope.push(Box::new(StackNode {\n\t\toperation: Box::new(String::new()),\n\t\tntype: Box::new(NodeType::Break),\n\t\targs: Box::new(vec![]),\n\t\tscope: Box::new(vec![]),\n\t}));\n}"}, "projects\\Fulcrum\\root\\src\\parts\\tcdefinitions.rs": "pub mod definitions;", "projects\\Fulcrum\\root\\src\\parts\\tokenizer.rs": "use indexmap::IndexMap;\n\nuse crate::parts::treecompiler::compile_tree;\n\nuse super::datastructures::{Token, StackNode};\n\npub fn tokenize (file_content:String, file_path:String, cli_args:Vec<String>) -> Box<IndexMap<String, Box<StackNode>>> {//create tokens from the file\n\t// TODO: Rework tree compiler to work on a single stack with more consistent rules.\n\t//buffers\n\tlet mut tokenlist:Vec<Token> = vec![];\n\tlet mut charbuff:String = String::new();\n\tlet mut is_string:bool = false;\n\tlet mut last_character:char = '\\n';\n\tlet mut list_stack:Vec<Token> = vec![];\n\tlet mut commenting = false;\n\n\tlet raw_lines = file_content.split(\"\\n\");\n\t//line loop\n\tfor (ln, raw_line) in raw_lines.enumerate() {\n\t\tlet line = raw_line.clone().trim().to_string();\n\t\t//Character loop\n\t\tfor (cn, character) in line.chars().enumerate() {\n\t\t\tif !commenting\n\t\t\t{\n\t\t\t\tif is_string {\n\t\t\t\t\tif character == '\\'' && last_character != '\\\\' {\n\t\t\t\t\t\tis_string = false;\n\t\t\t\t\t\ttokenlist.push(Token::StringLit(Box::new(charbuff.clone())));\n\t\t\t\t\t\tcharbuff = String::new()\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif last_character == '\\\\' {\n\t\t\t\t\t\t\tcharbuff.pop();\n\t\t\t\t\t\t\tmatch character {\n\t\t\t\t\t\t\t\t'n' => {\n\t\t\t\t\t\t\t\t\tcharbuff.push('\\n');\n\t\t\t\t\t\t\t\t\t//println!(\"newline\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t'r' => {\n\t\t\t\t\t\t\t\t\tcharbuff.push('\\r');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t't' => {\n\t\t\t\t\t\t\t\t\tcharbuff.push('\\t');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t'\\\\' => {\n\t\t\t\t\t\t\t\t\tcharbuff.push('\\\\');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t_ => {\n\t\t\t\t\t\t\t\t\tcharbuff.push(character.clone());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tcharbuff.push(character.clone());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlast_character = character.clone();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tmatch character {\n\t\t\t\t\t'=' => {\n\n\t\t\t\t\t\t// let mut newtok:Box<String> = Box::new(String::new());\n\t\t\t\t\t\t// match tokenlist.last().unwrap() {\n\t\t\t\t\t\t// \tToken::Variable(name) => newtok = Box::new(*name.clone()),\n\t\t\t\t\t\t// \t_ => {}\n\t\t\t\t\t\t// }\n\t\t\t\t\t\t// tokenlist.pop();\n\t\t\t\t\t\ttokenlist.push(Token::Assign);\n\t\t\t\t\t}\n\t\t\t\t\t'{' => {\n\t\t\t\t\t\ttokenlist.push(Token::StartScope);\n\t\t\t\t\t}\n\t\t\t\t\t'}' => {\n\t\t\t\t\t\ttokenlist.push(Token::EndScope);\n\t\t\t\t\t}\n\t\t\t\t\t'#' => {\n\t\t\t\t\t\tcommenting = true;\n\t\t\t\t\t}\n\t\t\t\t\t'(' => {\n\t\t\t\t\t\tmatch tokenlist.last() {\n\t\t\t\t\t\t\tSome(val) => {\n\t\t\t\t\t\t\t\tif val == &Token::FuncDeff(Box::new(String::new())) {\n\t\t\t\t\t\t\t\t\ttokenlist.pop();\n\t\t\t\t\t\t\t\t\ttokenlist.push(Token::FuncDeff(Box::new(charbuff)));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\ttokenlist.push(Token::FuncCall(Box::new(charbuff)));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tNone => tokenlist.push(Token::FuncCall(Box::new(charbuff))),\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcharbuff = String::new();\n\t\t\t\t\t}\n\t\t\t\t\t//delimeters\n\t\t\t\t\t' '|'\\t'|','|';'|')'|']'|'[' => {\n\t\t\t\t\t\tif charbuff != \"\" {\n\t\t\t\t\t\t\t//keywords\n\t\t\t\t\t\t\tif charbuff == \"return\" {\n\t\t\t\t\t\t\t\ttokenlist.push(Token::Return);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if charbuff == \"fun\" {\n\t\t\t\t\t\t\t\ttokenlist.push(Token::FuncDeff(Box::new(String::new())));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if charbuff == \"if\" {\n\t\t\t\t\t\t\t\ttokenlist.push(Token::If);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if charbuff == \"elif\" {\n\t\t\t\t\t\t\t\ttokenlist.push(Token::ElIf);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if charbuff == \"else\" {\n\t\t\t\t\t\t\t\ttokenlist.push(Token::El);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if charbuff == \"for\" {\n\t\t\t\t\t\t\t\ttokenlist.push(Token::For);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if charbuff == \"in\" {\n\t\t\t\t\t\t\t\ttokenlist.push(Token::In);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if charbuff == \"while\" {\n\t\t\t\t\t\t\t\ttokenlist.push(Token::While);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if charbuff == \"loop\" {\n\t\t\t\t\t\t\t\ttokenlist.push(Token::Loop);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if charbuff == \"break\" {\n\t\t\t\t\t\t\t\ttokenlist.push(Token::Break);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if vec![\"true\",\"t\",\"yes\"].contains(&charbuff.to_lowercase().as_str()) {\n\t\t\t\t\t\t\t\ttokenlist.push(Token::BooleanLit(Box::new(true)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if vec![\"false\",\"f\",\"no\"].contains(&charbuff.to_lowercase().as_str()) {\n\t\t\t\t\t\t\t\ttokenlist.push(Token::BooleanLit(Box::new(false)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if charbuff.chars().all(|ch| ch.is_alphanumeric() || ch == '_') && !charbuff.chars().all(char::is_numeric) {\n\t\t\t\t\t\t\t\t//keywords\n\t\t\t\t\t\t\t\ttokenlist.push(Token::Variable(Box::new(charbuff)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if charbuff.chars().all(|ch| ch.is_numeric() || ch == '.') || (charbuff.chars().all(|ch| ch.is_numeric() || ch == '-' || ch == '.') && charbuff.starts_with('-')) {\n\t\t\t\t\t\t\t\tif charbuff.contains('.') {\n\t\t\t\t\t\t\t\t\ttokenlist.push(Token::FloatLit(Box::new(charbuff.parse::<f64>().unwrap())));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\ttokenlist.push(Token::IntLit(Box::new(charbuff.parse::<i128>().unwrap())));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcharbuff = String::new();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif character == ')' {\n\t\t\t\t\t\t\ttokenlist.push(Token::StatementEnd);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif character == ',' {\n\t\t\t\t\t\t\ttokenlist.push(Token::Delimeter);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif character == ';' {\n\t\t\t\t\t\t\ttokenlist.push(Token::EndLine);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif character == ']' {\n\t\t\t\t\t\t\tmatch list_stack.last().unwrap() {\n\t\t\t\t\t\t\t\tToken::StartVec => {tokenlist.push(Token::EndVec);},\n\t\t\t\t\t\t\t\tToken::IndexStart => {tokenlist.push(Token::IndexEnd);},\n\t\t\t\t\t\t\t\t_ => {}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlist_stack.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif character == '[' {\n\t\t\t\t\t\t\tmatch tokenlist.last().unwrap() {\n\t\t\t\t\t\t\t\tToken::StringLit(_) | Token::StatementEnd | Token::EndVec | Token::IndexEnd | Token::Variable(_) => {\n\t\t\t\t\t\t\t\t\ttokenlist.push(Token::IndexStart);\n\t\t\t\t\t\t\t\t\tlist_stack.push(Token::IndexStart);\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t_ => {\n\t\t\t\t\t\t\t\t\ttokenlist.push(Token::StartVec);\n\t\t\t\t\t\t\t\t\tlist_stack.push(Token::StartVec);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t'\\'' => {\n\t\t\t\t\t\tis_string = !is_string;\n\t\t\t\t\t}\n\t\t\t\t\t_ => {\n\t\t\t\t\t\tcharbuff.push(character);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlast_character = character.clone();\n\t\t\t}\n\t\t}\n\t\tcommenting = false;\n\t}\n\t//println!(\"{:?}\", tokenlist);\n\tcompile_tree(tokenlist, file_path, cli_args)[0].clone()\n}", "projects\\Fulcrum\\root\\src\\parts\\treecompiler.rs": "use indexmap::IndexMap;\n\nuse crate::parts::{tcdefinitions::definitions::{return_val, scope_start, in_operator, break_keyword}, parser::Parser};\n\nuse super::{datastructures::{Token, StackNode}, tcdefinitions::definitions::{func_def, func_call, condition_if, condition_elif, condition_else, statement_end, assign, variable, literal, line_end, scope_end, vector, index, vec_end, end_index, loop_for, loop_while, loop_loop}};\n\n\n\npub fn compile_tree(tokenlist:Vec<Token>, file_path:String, cli_args:Vec<String>) -> Box<Vec<Box<IndexMap<String, Box<StackNode>>>>> {\n\t// tuple 0 = the node and tuple 1 = wether we are in the args or scope of that node\n\tlet mut stack_buffer:Box<Vec<(Box<StackNode>, Box<bool>)>> = Box::new(vec![(Box::new(StackNode::default()), Box::new(false))]);\n\tfor current_token in tokenlist.iter()\n\t{\n\t\t//println!(\"token number: {tn}\");\n\t\tmatch current_token {\n\t\t\tToken::FuncCall(name) => {\n\t\t\t\tfunc_call(*name.clone(), &mut stack_buffer);\n\t\t\t},\n\t\t\tToken::FuncDeff(name) => {\n\t\t\t\tfunc_def(*name.clone(), &mut stack_buffer);\n\t\t\t},\n\t\t\tToken::If => {\n\t\t\t\tcondition_if(&mut stack_buffer);\n\t\t\t},\n\t\t\tToken::ElIf => {\n\t\t\t\tcondition_elif(&mut stack_buffer);\n\t\t\t},\n\t\t\tToken::El => {\n\t\t\t\tcondition_else(&mut stack_buffer);\n\t\t\t},\n\t\t\tToken::StatementEnd => {\n\t\t\t\tstatement_end(&mut stack_buffer);\n\t\t\t},\n\t\t\tToken::StringLit(_) => {\n\t\t\t\tliteral(current_token.clone(), &mut stack_buffer);\n\t\t\t},\n\t\t\tToken::IntLit(_) => {\n\t\t\t\tliteral(current_token.clone(), &mut stack_buffer);\n\t\t\t},\n\t\t\tToken::FloatLit(_) => {\n\t\t\t\tliteral(current_token.clone(), &mut stack_buffer);\n\t\t\t},\n\t\t\tToken::BooleanLit(_) => {\n\t\t\t\tliteral(current_token.clone(), &mut stack_buffer);\n\t\t\t},\n\t\t\tToken::StartScope => {\n\t\t\t\tscope_start(&mut stack_buffer);\n\t\t\t},\n\t\t\tToken::EndScope => {\n\t\t\t\tscope_end(&mut stack_buffer);\n\t\t\t},\n\t\t\tToken::Variable(name) => {\n\t\t\t\tvariable(*name.clone(), &mut stack_buffer);\n\t\t\t},\n\t\t\tToken::Assign => {\n\t\t\t\tassign(&mut stack_buffer);\n\t\t\t},\n\t\t\tToken::Return => {\n\t\t\t\treturn_val(&mut stack_buffer);\n\t\t\t},\n\t\t\tToken::EndLine => {\n\t\t\t\tline_end(&mut stack_buffer);\n\t\t\t},\n\t\t\tToken::StartVec => {\n\t\t\t\tvector(&mut stack_buffer);\n\t\t\t},\n\t\t\tToken::EndVec => {\n\t\t\t\tvec_end(&mut stack_buffer);\n\t\t\t},\n\t\t\tToken::IndexStart => {\n\t\t\t\tindex(&mut stack_buffer);\n\t\t\t},\n\t\t\tToken::IndexEnd => {\n\t\t\t\tend_index(&mut stack_buffer);\n\t\t\t}\n\t\t\tToken::Delimeter => {},\n\t\t\tToken::For => {\n\t\t\t\tloop_for(&mut stack_buffer);\n\t\t\t}\n\t\t\tToken::In => {\n\t\t\t\tin_operator(&mut stack_buffer);\n\t\t\t},\n\t\t\tToken::While => {\n\t\t\t\tloop_while(&mut stack_buffer);\n\t\t\t},\n\t\t\tToken::Loop => {\n\t\t\t\tloop_loop(&mut stack_buffer);\n\t\t\t}\n\t\t\tToken::Break => {\n\t\t\t\tbreak_keyword(&mut stack_buffer);\n\t\t\t}\n\t\t}\n\t}\n\t//println!(\"{:?}\", stack_buffer);\n\tlet mut executor = Parser {\n\t\tfile_path,\n\t\tcli_args,\n\t\tstack: Box::new(vec![]),\n\t};\n\texecutor.parse_tree(stack_buffer[0].0.clone());\n\t//println!(\"{:?}\", executor.stack);\n\texecutor.stack\n}"}, "projects\\Fulcrum\\root\\src\\parts.rs": "pub mod tokenizer;\npub mod datastructures;\npub mod treecompiler;\npub mod tcdefinitions;\npub mod parser;"}, "projects\\Fulcrum\\root\\tests": {"projects\\Fulcrum\\root\\tests\\start.ful": "fun tictactoe() {\n\t# Board will act as a global that will hold the state of the tic tac toe board.\n\tboard = [\n\t\t# 1   2   3\n\t\t[' ',' ',' '], #a\n\t\t[' ',' ',' '], #b\n\t\t[' ',' ',' ']  #c\n\t];\n\n\tfun check_winner() {\n\t\t#horizontal\n\t\tif E(board[0], ['O', 'O', 'O']) {\n\t\t\treturn 'O';\n\t\t}\n\t\telif E(board[0], ['X', 'X', 'X']) {\n\t\t\treturn 'X';\n\t\t}\n\t\telif E(board[1], ['O', 'O', 'O']) {\n\t\t\treturn 'O';\n\t\t}\n\t\telif E(board[1], ['X', 'X', 'X']) {\n\t\t\treturn 'X';\n\t\t}\n\t\telif E(board[2], ['O', 'O', 'O']) {\n\t\t\treturn 'O';\n\t\t}\n\t\telif E(board[2], ['X', 'X', 'X']) {\n\t\t\treturn 'X';\n\t\t}\n\t\t#vertical\n\t\telif and(and(E(board[0][0], 'O'), E(board[1][0], 'O')), E(board[2][0], 'O')) {\n\t\t\treturn 'O';\n\t\t}\n\t\telif and(and(E(board[0][0], 'X'), E(board[1][0], 'X')), E(board[2][0], 'X')) {\n\t\t\treturn 'X';\n\t\t}\n\t\telif and(and(E(board[0][1], 'O'), E(board[1][1], 'O')), E(board[2][1], 'O')) {\n\t\t\treturn 'O';\n\t\t}\n\t\telif and(and(E(board[0][1], 'X'), E(board[1][1], 'X')), E(board[2][1], 'X')) {\n\t\t\treturn 'X';\n\t\t}\n\t\telif and(and(E(board[0][2], 'O'), E(board[1][2], 'O')), E(board[2][2], 'O')) {\n\t\t\treturn 'O';\n\t\t}\n\t\telif and(and(E(board[0][2], 'X'), E(board[1][2], 'X')), E(board[2][2], 'X')) {\n\t\t\treturn 'X';\n\t\t}\n\t\t#diagonal\n\t\telif and(and(E(board[0][0], 'O'), E(board[1][1], 'O')), E(board[2][2], 'O')) {\n\t\t\treturn 'O';\n\t\t}\n\t\telif and(and(E(board[0][0], 'X'), E(board[1][1], 'X')), E(board[2][2], 'X')) {\n\t\t\treturn 'X';\n\t\t}\n\t\telif and(and(E(board[2][0], 'O'), E(board[1][1], 'O')), E(board[0][2], 'O')) {\n\t\t\treturn 'O';\n\t\t}\n\t\telif and(and(E(board[2][0], 'X'), E(board[1][1], 'X')), E(board[0][2], 'X')) {\n\t\t\treturn 'X';\n\t\t}\n\n\t\treturn '';\n\t}\n\n\tfun update_board(current_player) {\n\t\t# This function starts a turn for a player.\n\n\t\tfun print_board() {\n\t\t\t# this function renders the current board.\n\t\t\t# board is inherited from top most function and acts as a global.\n\t\t\tprint(add(add(add(add(board[0][0], '|'),board[0][1]),'|'),board[0][2]));\n\t\t\tprint('\\n-----\\n');\n\t\t\tprint(add(add(add(add(board[1][0], '|'),board[1][1]),'|'),board[1][2]));\n\t\t\tprint('\\n-----\\n');\n\t\t\tprint(add(add(add(add(board[2][0], '|'),board[2][1]),'|'),board[2][2]));\n\t\t\tprint('\\n');\n\t\t}\n\n\t\t# render the board at the start of the turn\n\t\tprint_board();\n\n\t\t# check for a winner\n\t\tis_winner = check_winner();\n\t\tif is_winner {\n\t\t\twrite('tictactoe_wins.txt', add(is_winner, ', '), 'a');\n\t\t\tprint(add(add('The winner is: ', is_winner), '\\n'));\n\t\t\tprint('Previous wins:\\n');\n\t\t\tprint(read('tictactoe_wins.txt'));\n\t\t\treturn is_winner;\n\t\t}\n\n\t\t# Get horizontal input.\n\t\tprint('horizontal:');\n\t\tx = sub(INT(input()),1);\n\t\t\n\t\t# Get vertical input.\n\t\tprint('vertical:');\n\t\ty = sub(INT(input()), 1);\n\t\t\n\t\t# Set the current player at that position.\n\t\tboard[x][y] = current_player;\n\t\t\n\t\t# Check who the current player is to recursively call update board as the other player.\n\t\tif E(current_player, 'X') {\n\t\t\treturn update_board('O');\n\t\t}\n\t\telse {\n\t\t\treturn update_board('X');\n\t\t}\n\t}\n\treturn update_board('X');\n}\n\n# Run the game\ntictactoe();", "projects\\Fulcrum\\root\\tests\\tictactoe_wins.txt": "X, X, X, X, X, X, X, ", "projects\\Fulcrum\\root\\tests\\tokens.txt": "some new content. some more new content"}}}}