{"pgs": {"Getting Started": "# Fulcrum 0.8.8\nA fast and straight forward scripting language with a tiny binary and a functional programming paradigm. \n\n## Documentation\n\n## Features:\n\n - Higher order functions.\n\n - An extremely minimal and basic syntax.\n\n - An compact interpreter that can be packaged with your project.\n\n## Language Rules:\n\n - Assignments, function calls, and return statements must be ended with a `;`\n\n - Operators are not yet a part of the language but operations can be done via functions.\n\n - Functions defined inside of other functions only are callable inside of the parent function and inherit all of the parent function's variables and function definitions.\n\n - Higher order functions must include a function name, this requirement will be taken out once a new syntax for function literals is added.\n\n - When exiting any scope, all variables defined within that scope are deleted.\n\n - Nothing is passed by reference, all variables are modified via the `=` asignment operator.\n", "Non Traditional Functionalities": "## Non-traditional Functionalities\n\n - Loops\n\n```\nloop {\n\tprint(\"Loop!\\n\");\n}\n```\n\nLoops will loop until the path of execution hits a `break` or a `return`.\n\n - For loops\n\n```\n// String Example\n\nfor i in \"abc\" {\n\tprint(add(i, \"\\n\"));\n}\n\n// output:\n// a\n// b\n// c\n\n// Integer Example\n\nfor i in 3 {\n\tprint(add(i, \"\\n\"));\n}\n\n// output:\n// 0\n// 1\n// 2\n\n// List Example\n\nfor i in [\"1\", 2.0, 3] {\n\tprint(add(i, \"\\n\"));\n}\n\n// output:\n// 1\n// 2.0\n// 3\n\n// Variable Example\n\nvariable = [0, 1, 2];\nfor i in variable {\n\tprint(add(i, \"\\n\"));\n}\n\n// output:\n// 0\n// 1\n// 2\n```\n\n", "Language Keywords And Syntax": "## Language Keywords and syntax:\n\n - `fun` : Prefixes a function definition.\n\n - `return` : Returns a value from a user defined function.\n\n - `break` : Breaks out of a scope.\n\n - `if` : Prefixes the condition for an if block.\n\n - `elif` : Prefixes the condition for an elif block.\n\n - `else` : Prefixes an else block.\n\n - `loop` : Prefixes a loop block. Loop blocks will loop indefinitely until they hit a break or return.\n\n - `while` : Prefixes a while block. while blocks will loop as long as their statement is true.\n\n - `[]` : Wraps a list literal or is used to hold the offset for an index/offset operator.\n\n - `=` : Used to declare or assign to existing variables.\n\n - `\"` : Wraps a string literal.\n\n - `in` : Operator that checks if the left side is in the right side when not used inside a for loop.\n\n\n - `;` : Denotes the end of a line.\n\n - `()` : Suffixes a function name when calling or declaring that function. Wraps function arguments when calling a function and wraps function argument names when declaring a function.\n\n - `true`|`yes`|`t` : Aliases for the boolean literal `true`.\n\n - `false`|`no`|`f` : Aliases for the boolean literal `false`.\n\n", "Functions": "## Standard Library Functions:\n\nFunctions in fulcrum return the result of their operation.\n\n - `print(val)` : Prints a value to the standard output.\n\n - `input()` : Gets user input.\n\n - `read(filepath)` : Returns the contents of the file provided.\n\n - `write(filepath, new_content, writemode)` : Writes the `new_content` to the file provided based on the writemode which can be `\"a\"` for append or `\"t\"` for truncate.\n\n - `add(val1, val2)` : Adds 2 values. also concatenates strings.\n\n - `sub(val1, val2)` : Subtracts 2 values. also removes substrings from strings.\n\n - `mul(val1, val2)` : Multiplies 2 values.\n\n - `div(val1, val2)` : divides 2 values.\n\n - `E(val1, val2)` : Tests if two values are equal and returns boolean.\n\n - `NE(val1, val2)` : Tests if two values are not equal and returns boolean.\n\n - `G(val1, val2)` : Tests if `val1` is greater than `val2`.\n\n - `L(val1, val2)` : Tests if `val1` is less than `val2`.\n\n - `GE(val1, val2)` : Tests if `val1` is greater than or equal to `val2`.\n\n - `LE(val1, val2)` : Tests if `val1` is less than or equal to `val2`.\n\n - `and(condition1, condition2)` : Tests if both conditions are true and returns boolean.\n\n - `or(condition1, condition2)` : Tests if one of the conditions are true and returns boolean.\n\n - `INT(val)` : Casts the type to an Int.\n\n - `FLOAT(val)` : Casts the type to a Float.\n\n - `BOOL(val)` : Casts the type to a Boolean.\n\n - `STRING(val)` : Casts the type to a String.\n\n - `cat(val1, val2, val3, ...)` : Concatenates multiple values into a string.\n\n - `split(string, substring)` : Splits a string by a substring.\n\n - `trim(string)` : Removes the leading and trailing whitespace from a string.\n\n - `replace(string, substring1, substring2)` : Replaces the substring1 in the string with substring2.\n\n - `pop(list)` : pops a value from a list.\n \n - `push(list, value)` : pops a value from a list.\n\n - `len(string`|`list)` : Returns the len of the first argument.\n\n - `range(num1, num2)` : Returns a list of integers from num1 to num2.\n\n - `rev(list`|`string)` : Reverses a list or string.\n\n - `CLI(integer)` : Returns command line arguments.\n\n - `import(module_path)` : imports all definitions/functions from the `.ful` file at the path specified into the current scope.", "Example Program": "## Example Program:\n\nTic Tac Toe:\n```\n# tictactoe.ful\nfun tictactoe() {\n\t# Board will act as a global that will hold the state of the tic tac toe board.\n\tboard = [\n\t\t# 1   2   3\n\t\t[\" \",\" \",\" \"], #a\n\t\t[\" \",\" \",\" \"], #b\n\t\t[\" \",\" \",\" \"]  #c\n\t];\n\n\tfun check_winner() {\n\t\t#horizontal\n\t\tif E(board[0], [\"O\", \"O\", \"O\"]) {\n\t\t\treturn \"O\";\n\t\t}\n\t\telif E(board[0], [\"X\", \"X\", \"X\"]) {\n\t\t\treturn \"X\";\n\t\t}\n\t\telif E(board[1], [\"O\", \"O\", \"O\"]) {\n\t\t\treturn \"O\";\n\t\t}\n\t\telif E(board[1], [\"X\", \"X\", \"X\"]) {\n\t\t\treturn \"X\";\n\t\t}\n\t\telif E(board[2], [\"O\", \"O\", \"O\"]) {\n\t\t\treturn \"O\";\n\t\t}\n\t\telif E(board[2], [\"X\", \"X\", \"X\"]) {\n\t\t\treturn \"X\";\n\t\t}\n\t\t#vertical\n\t\telif and(and(E(board[0][0], \"O\"), E(board[1][0], \"O\")), E(board[2][0], \"O\")) {\n\t\t\treturn \"O\";\n\t\t}\n\t\telif and(and(E(board[0][0], \"X\"), E(board[1][0], \"X\")), E(board[2][0], \"X\")) {\n\t\t\treturn \"X\";\n\t\t}\n\t\telif and(and(E(board[0][1], \"O\"), E(board[1][1], \"O\")), E(board[2][1], \"O\")) {\n\t\t\treturn \"O\";\n\t\t}\n\t\telif and(and(E(board[0][1], \"X\"), E(board[1][1], \"X\")), E(board[2][1], \"X\")) {\n\t\t\treturn \"X\";\n\t\t}\n\t\telif and(and(E(board[0][2], \"O\"), E(board[1][2], \"O\")), E(board[2][2], \"O\")) {\n\t\t\treturn \"O\";\n\t\t}\n\t\telif and(and(E(board[0][2], \"X\"), E(board[1][2], \"X\")), E(board[2][2], \"X\")) {\n\t\t\treturn \"X\";\n\t\t}\n\t\t#diagonal\n\t\telif and(and(E(board[0][0], \"O\"), E(board[1][1], \"O\")), E(board[2][2], \"O\")) {\n\t\t\treturn \"O\";\n\t\t}\n\t\telif and(and(E(board[0][0], \"X\"), E(board[1][1], \"X\")), E(board[2][2], \"X\")) {\n\t\t\treturn \"X\";\n\t\t}\n\t\telif and(and(E(board[2][0], \"O\"), E(board[1][1], \"O\")), E(board[0][2], \"O\")) {\n\t\t\treturn \"O\";\n\t\t}\n\t\telif and(and(E(board[2][0], \"X\"), E(board[1][1], \"X\")), E(board[0][2], \"X\")) {\n\t\t\treturn \"X\";\n\t\t}\n\n\t\treturn \"\";\n\t}\n\n\tfun update_board(current_player) {\n\t\t# This function starts a turn for a player.\n\n\t\tfun print_board() {\n\t\t\t# this function renders the current board.\n\t\t\t# board is inherited from top most function and acts as a global.\n\t\t\tprint(add(add(add(add(board[0][0], \"|\"),board[0][1]),\"|\"),board[0][2]));\n\t\t\tprint(\"\\n-----\\n\");\n\t\t\tprint(add(add(add(add(board[1][0], \"|\"),board[1][1]),\"|\"),board[1][2]));\n\t\t\tprint(\"\\n-----\\n\");\n\t\t\tprint(add(add(add(add(board[2][0], \"|\"),board[2][1]),\"|\"),board[2][2]));\n\t\t\tprint(\"\\n\");\n\t\t}\n\n\t\t# render the board at the start of the turn\n\t\tprint_board();\n\n\t\t# check for a winner\n\t\tis_winner = check_winner();\n\t\tif is_winner {\n\t\t\twrite(\"tictactoe_wins.txt\", add(is_winner, \", \"), \"a\");\n\t\t\tprint(add(add(\"The winner is: \", is_winner), \"\\n\"));\n\t\t\tprint(\"Previous wins:\\n\");\n\t\t\tprint(read(\"tictactoe_wins.txt\"));\n\t\t\treturn is_winner;\n\t\t}\n\n\t\t# Get horizontal input.\n\t\tprint(\"horizontal:\");\n\t\tx = sub(INT(input()),1);\n\t\t\n\t\t# Get vertical input.\n\t\tprint(\"vertical:\");\n\t\ty = sub(INT(input()), 1);\n\t\t\n\t\t# Set the current player at that position.\n\t\tboard[x][y] = current_player;\n\t\t\n\t\t# Check who the current player is to recursively call update board as the other player.\n\t\tif E(current_player, \"X\") {\n\t\t\treturn update_board(\"O\");\n\t\t}\n\t\telse {\n\t\t\treturn update_board(\"X\");\n\t\t}\n\t}\n\treturn update_board(\"X\");\n}\n\n# Run the game\ntictactoe();\n```"}}